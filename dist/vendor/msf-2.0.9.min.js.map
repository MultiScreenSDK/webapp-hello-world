{"version":3,"sources":["msf:///msf-2.0.9.min.js?","msf:///webpack/bootstrap ac564d9e737f1af9e4c3?","msf:///./index.js?","msf:///./lib/msf.js?","msf:///./lib/EventEmitter.js?","msf:///./lib/Service.js?","msf:///./lib/Search.js?","msf:///./lib/util/index.js?","msf:///./lib/Application.js?","msf:///./lib/Channel.js?","msf:///./lib/util/url.js?","msf:///./lib/util/inherits.js?","msf:///./lib/util/props.js?","msf:///./lib/util/types.js?","msf:///./lib/util/querystring.js?","msf:///./lib/Client.js?","msf:///./lib/ClientList.js?"],"names":["msf","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","undefined","EventEmitter","Service","Search","search","callback","once","services","setTimeout","start","local","getLocal","remote","uri","getByURI","this","_events","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","prototype","defaultMaxListeners","setMaxListeners","n","isNaN","TypeError","emit","type","er","handler","len","args","i","listeners","error","length","arguments","Error","Array","apply","slice","addListener","listener","newListener","push","warned","console","trace","on","g","removeListener","fired","list","position","splice","off","removeAllListeners","key","ret","listenerCount","emitter","description","name","version","device","props","readOnly","util","Application","Channel","application","channelURI","channel","oReq","XMLHttpRequest","timeout","ontimeout","onload","status","result","JSON","parse","responseText","e","open","send","super_","discoveryFrame","STATUS_STOPPED","self","frame","document","createElement","setAttribute","style","display","src","body","appendChild","windowMessageListener","event","source","contentWindow","data","onSearchReady","results","onSearchResult","onSearchError","window","addEventListener","inherits","STATUS_STARTED","postMessage","method","warn","stop","url","types","queryString","service","isString","match","startOnConnect","stopOnDisconnect","disconnectWithHost","clients","me","isHost","client","disconnect","getInfo","invoke","install","oServiceUrl","ClientList","Object","defineProperty","get","connection","readyState","clientId","resultHandlers","connectionUrl","host","pathname","Client","packMessage","oMsg","payload","msg","stringify","msgByteLength","Blob","size","hBuff","ArrayBuffer","hView","DataView","setUint16","unpackMessage","buffer","json","view","msgByteLen","getUint16","String","fromCharCode","getUint8","message","params","isNotification","isConnected","Date","now","connect","attributes","u","WebSocket","binaryType","onopen","_onSocketOpen","bind","onerror","_onSocketError","onclose","_onSocketClose","onmessage","_onSocketMessage","close","publish","target","isArray","to","clear","unpacked","forEach","clientInfo","getById","remove","from","isValid","pattern","oUrl","parser","href","protocol","hostname","port","hash","create","ctor","superCtor","constructor","value","enumerable","writable","configurable","TempCtor","createDescriptor","w","v","obj","k","private","isNull","isBoolean","str","trim","replace","split","reduce","param","parts","val","decodeURIComponent","hasOwnProperty","keys","map","val2","encodeURIComponent","join","ChannelClient","connectTime","freeze","item","indexOf"],"mappings":"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","file":"msf-2.0.9.min.js","sourcesContent":["var msf =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\r\n\t\r\n\tvar msf = __webpack_require__(1);\r\n\t\r\n\tif (true) {\r\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return msf; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t} else if (typeof module !== 'undefined' && module.exports) {\r\n\t    module.exports = msf;\r\n\t} else {\r\n\t    window.msf = msf;\r\n\t}\r\n\t\r\n\tmodule.exports = msf;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util = __webpack_require__(5);\r\n\tvar EventEmitter = __webpack_require__(2);\r\n\tvar Service = __webpack_require__(3);\r\n\tvar Search = __webpack_require__(4);\r\n\t\r\n\t// We will use a singleton for search so that we don't create multiple frames in the page\r\n\tvar search = null;\r\n\t\r\n\t\r\n\t/**\r\n\t * The entry point for the API\r\n\t *\r\n\t * @namespace msf\r\n\t * @type {EventEmitter}\r\n\t *\r\n\t */\r\n\tvar msf = new EventEmitter();\r\n\t\r\n\t\r\n\t/**\r\n\t * Searches the local network for compatible multiscreen services\r\n\t *\r\n\t * @param {Function} [callback] If a callback is passed the search is immediately started.\r\n\t * @param {Error} callback.err The callback handler\r\n\t * @param {Array} callback.result An array of {@link Service} instances found on the network\r\n\t * @returns {Search} A search instance (a singleton is used to reduce page resources)\r\n\t *\r\n\t */\r\n\tmsf.search = function(callback){\r\n\t\r\n\t    // Create the single instance if we don't already have one\r\n\t    if(!search) search = new Search();\r\n\t\r\n\t    // If there is a callback defined, listen once for results and start the search\r\n\t    if(callback) {\r\n\t        search.once('found',function(services){\r\n\t            callback(null, services);\r\n\t        });\r\n\t\r\n\t        // start on next tick to support search callbacks and events\r\n\t        setTimeout(function(){ search.start(); },0);\r\n\t\r\n\t    }\r\n\t\r\n\t    return search;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Retrieves a reference to the service running on the current device\r\n\t *\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Error} callback.error\r\n\t * @param {Service} callback.service The service instance\r\n\t *\r\n\t */\r\n\tmsf.local = function(callback){\r\n\t\r\n\t    Service.getLocal(callback);\r\n\t\r\n\t};\r\n\t\r\n\t/**\r\n\t * Retrieves a service instance by it's uri\r\n\t *\r\n\t * @param {String} uri The uri of the service (http://<ip>:<port>/api/v2/)\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Error} callback.error\r\n\t * @param {Service} callback.service The service instance\r\n\t *\r\n\t */\r\n\tmsf.remote = function(uri, callback){\r\n\t\r\n\t    Service.getByURI(uri, callback);\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\tmodule.exports = msf;\r\n\t\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* jshint newcap: false, -W040: false, -W004: false, -W003 : false */\r\n\t\r\n\t\"use strict\";\r\n\t\r\n\t/**\r\n\t * Based on nodejs EventEmitter\r\n\t *\r\n\t * - addition of 'off' method as an alias to `removeListener`\r\n\t *\r\n\t * All objects which emit events are instances of EventEmitter.\r\n\t * For more information see http://nodejs.org/api/events.html\r\n\t *\r\n\t * @namespace EventEmitter\r\n\t *\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * Adds a listener to the end of the listeners array for the specified event.\r\n\t * @method addListener\r\n\t * @memberOf EventEmitter.prototype\r\n\t * @param {String} event The event name to listen to\r\n\t * @param {Function} listener The function to invoke when the event occurs\r\n\t * @return EventEmitter\r\n\t *\r\n\t */\r\n\t\r\n\t/**\r\n\t * Alias for addListener method\r\n\t * @method on\r\n\t * @memberOf EventEmitter.prototype\r\n\t * @param {String} event The event name to listen to\r\n\t * @param {Function} listener The function to invoke when the event occurs\r\n\t * @return EventEmitter\r\n\t *\r\n\t */\r\n\t\r\n\t/**\r\n\t * Adds a one time listener for the event. This listener is invoked only the next time the event is fired, after which it is removed.\r\n\t * @method once\r\n\t * @memberOf EventEmitter.prototype\r\n\t * @param {String} event The event name to listen to\r\n\t * @param {Function} listener The function to invoke when the event occurs\r\n\t * return EventEmitter\r\n\t *\r\n\t */\r\n\t\r\n\t/**\r\n\t * Remove a listener from the listener array for the specified event. Caution: changes array indices in the listener array behind the listener.\r\n\t * @method removeListener\r\n\t * @memberOf EventEmitter.prototype\r\n\t * @param {String} event The event name to stop listening to\r\n\t * @param {Function} listener The function that was originally add to handle the event\r\n\t * @return EventEmitter\r\n\t *\r\n\t */\r\n\t\r\n\t/**\r\n\t * Alias for removeListener\r\n\t * @method off\r\n\t * @memberOf EventEmitter.prototype\r\n\t * @param {String} event The event name to stop listening to\r\n\t * @param {Function} listener The function that was originally add to handle the event\r\n\t * @return EventEmitter\r\n\t *\r\n\t */\r\n\t\r\n\t/**\r\n\t * Removes all listeners, or those of the specified event.\r\n\t * @method removeAllListeners\r\n\t * @memberOf EventEmitter.prototype\r\n\t * @param {String} event The event name to stop listening to\r\n\t * @return EventEmitter\r\n\t *\r\n\t */\r\n\t\r\n\t/**\r\n\t * By default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default which helps finding memory leaks. Obviously not all Emitters should be limited to 10. This function allows that to be increased. Set to zero for unlimited.\r\n\t * @method setMaxListeners\r\n\t * @memberOf EventEmitter.prototype\r\n\t * @param {Number} n The maximum number of listeners\r\n\t *\r\n\t */\r\n\t\r\n\t/**\r\n\t * Returns an array of listeners for the specified event.\r\n\t * @method listeners\r\n\t * @memberOf EventEmitter.prototype\r\n\t * @param {String} event The event name the listeners are currently bound to\r\n\t * @return Array\r\n\t *\r\n\t */\r\n\t\r\n\t/**\r\n\t * Returns true if event had listeners, false otherwise.\r\n\t * @method emit\r\n\t * @memberOf EventEmitter.prototype\r\n\t * @param {String} event The event name the listeners are currently bound to\r\n\t * @param {any}[args]*\r\n\t * @return Boolean\r\n\t *\r\n\t */\r\n\t\r\n\t/**\r\n\t * Returns true if event had listeners, false otherwise.\r\n\t * @method listenerCount\r\n\t * @static\r\n\t * @memberOf EventEmitter\r\n\t * @param {EventEmitter} emitter\r\n\t * @param {String} event The event name the listeners are currently bound to\r\n\t * @return Number\r\n\t *\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t This event is emitted any time someone adds a new listener. It is unspecified if listener is in the list returned by emitter.listeners(event).\r\n\t @event EventEmitter#newListener\r\n\t @property {String} event The event name\r\n\t @property {Function} listener The event handler function\r\n\t **/\r\n\t\r\n\t/**\r\n\t This event is emitted any time someone removes a listener. It is unspecified if listener is in the list returned by emitter.listeners(event).\r\n\t @event EventEmitter#removeListener\r\n\t @property {String} event The event name\r\n\t @property {Function} listener The event handler function\r\n\t **/\r\n\t\r\n\t// Copyright Joyent, Inc. and other Node contributors.\r\n\t//\r\n\t// Permission is hereby granted, free of charge, to any person obtaining a\r\n\t// copy of this software and associated documentation files (the\r\n\t// \"Software\"), to deal in the Software without restriction, including\r\n\t// without limitation the rights to use, copy, modify, merge, publish,\r\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n\t// persons to whom the Software is furnished to do so, subject to the\r\n\t// following conditions:\r\n\t//\r\n\t// The above copyright notice and this permission notice shall be included\r\n\t// in all copies or substantial portions of the Software.\r\n\t//\r\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\t\r\n\tfunction EventEmitter() {\r\n\t this._events = this._events || {};\r\n\t this._maxListeners = this._maxListeners || undefined;\r\n\t}\r\n\tmodule.exports = EventEmitter;\r\n\t\r\n\t// Backwards-compat with node 0.10.x\r\n\tEventEmitter.EventEmitter = EventEmitter;\r\n\t\r\n\tEventEmitter.prototype._events = undefined;\r\n\tEventEmitter.prototype._maxListeners = undefined;\r\n\t\r\n\t// By default EventEmitters will print a warning if more than 10 listeners are\r\n\t// added to it. This is a useful default which helps finding memory leaks.\r\n\tEventEmitter.defaultMaxListeners = 10;\r\n\t\r\n\t// Obviously not all Emitters should be limited to 10. This function allows\r\n\t// that to be increased. Set to zero for unlimited.\r\n\tEventEmitter.prototype.setMaxListeners = function(n) {\r\n\t if (!isNumber(n) || n < 0 || isNaN(n))\r\n\t  throw TypeError('n must be a positive number');\r\n\t this._maxListeners = n;\r\n\t return this;\r\n\t};\r\n\t\r\n\tEventEmitter.prototype.emit = function(type) {\r\n\t var er, handler, len, args, i, listeners;\r\n\t\r\n\t if (!this._events)\r\n\t  this._events = {};\r\n\t\r\n\t // If there is no 'error' event listener then throw.\r\n\t if (type === 'error') {\r\n\t  if (!this._events.error ||\r\n\t      (isObject(this._events.error) && !this._events.error.length)) {\r\n\t   er = arguments[1];\r\n\t   if (er instanceof Error) {\r\n\t    throw er; // Unhandled 'error' event\r\n\t   }\r\n\t   throw TypeError('Uncaught, unspecified \"error\" event.');\r\n\t  }\r\n\t }\r\n\t\r\n\t handler = this._events[type];\r\n\t\r\n\t if (isUndefined(handler))\r\n\t  return false;\r\n\t\r\n\t if (isFunction(handler)) {\r\n\t  switch (arguments.length) {\r\n\t   // fast cases\r\n\t   case 1:\r\n\t    handler.call(this);\r\n\t    break;\r\n\t   case 2:\r\n\t    handler.call(this, arguments[1]);\r\n\t    break;\r\n\t   case 3:\r\n\t    handler.call(this, arguments[1], arguments[2]);\r\n\t    break;\r\n\t   // slower\r\n\t   default:\r\n\t    len = arguments.length;\r\n\t    args = new Array(len - 1);\r\n\t    for (i = 1; i < len; i++)\r\n\t     args[i - 1] = arguments[i];\r\n\t    handler.apply(this, args);\r\n\t  }\r\n\t } else if (isObject(handler)) {\r\n\t  len = arguments.length;\r\n\t  args = new Array(len - 1);\r\n\t  for (i = 1; i < len; i++)\r\n\t   args[i - 1] = arguments[i];\r\n\t\r\n\t  listeners = handler.slice();\r\n\t  len = listeners.length;\r\n\t  for (i = 0; i < len; i++)\r\n\t   listeners[i].apply(this, args);\r\n\t }\r\n\t\r\n\t return true;\r\n\t};\r\n\t\r\n\tEventEmitter.prototype.addListener = function(type, listener) {\r\n\t var m;\r\n\t\r\n\t if (!isFunction(listener))\r\n\t  throw TypeError('listener must be a function');\r\n\t\r\n\t if (!this._events)\r\n\t  this._events = {};\r\n\t\r\n\t // To avoid recursion in the case that type === \"newListener\"! Before\r\n\t // adding it to the listeners, first emit \"newListener\".\r\n\t if (this._events.newListener)\r\n\t  this.emit('newListener', type,\r\n\t      isFunction(listener.listener) ?\r\n\t          listener.listener : listener);\r\n\t\r\n\t if (!this._events[type])\r\n\t // Optimize the case of one listener. Don't need the extra array object.\r\n\t  this._events[type] = listener;\r\n\t else if (isObject(this._events[type]))\r\n\t // If we've already got an array, just append.\r\n\t  this._events[type].push(listener);\r\n\t else\r\n\t // Adding the second element, need to change to array.\r\n\t  this._events[type] = [this._events[type], listener];\r\n\t\r\n\t // Check for listener leak\r\n\t if (isObject(this._events[type]) && !this._events[type].warned) {\r\n\t  var m;\r\n\t  if (!isUndefined(this._maxListeners)) {\r\n\t   m = this._maxListeners;\r\n\t  } else {\r\n\t   m = EventEmitter.defaultMaxListeners;\r\n\t  }\r\n\t\r\n\t  if (m && m > 0 && this._events[type].length > m) {\r\n\t   this._events[type].warned = true;\r\n\t   console.error('(node) warning: possible EventEmitter memory ' +\r\n\t       'leak detected. %d listeners added. ' +\r\n\t       'Use emitter.setMaxListeners() to increase limit.',\r\n\t       this._events[type].length);\r\n\t   if (typeof console.trace === 'function') {\r\n\t    // not supported in IE 10\r\n\t    console.trace();\r\n\t   }\r\n\t  }\r\n\t }\r\n\t\r\n\t return this;\r\n\t};\r\n\t\r\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\r\n\t\r\n\tEventEmitter.prototype.once = function(type, listener) {\r\n\t if (!isFunction(listener))\r\n\t  throw TypeError('listener must be a function');\r\n\t\r\n\t var fired = false;\r\n\t\r\n\t function g() {\r\n\t  this.removeListener(type, g);\r\n\t\r\n\t  if (!fired) {\r\n\t   fired = true;\r\n\t   listener.apply(this, arguments);\r\n\t  }\r\n\t }\r\n\t\r\n\t g.listener = listener;\r\n\t this.on(type, g);\r\n\t\r\n\t return this;\r\n\t};\r\n\t\r\n\t// emits a 'removeListener' event iff the listener was removed\r\n\tEventEmitter.prototype.removeListener = function(type, listener) {\r\n\t var list, position, length, i;\r\n\t\r\n\t if (!isFunction(listener))\r\n\t  throw TypeError('listener must be a function');\r\n\t\r\n\t if (!this._events || !this._events[type])\r\n\t  return this;\r\n\t\r\n\t list = this._events[type];\r\n\t length = list.length;\r\n\t position = -1;\r\n\t\r\n\t if (list === listener ||\r\n\t     (isFunction(list.listener) && list.listener === listener)) {\r\n\t  delete this._events[type];\r\n\t  if (this._events.removeListener)\r\n\t   this.emit('removeListener', type, listener);\r\n\t\r\n\t } else if (isObject(list)) {\r\n\t  for (i = length; i-- > 0;) {\r\n\t   if (list[i] === listener ||\r\n\t       (list[i].listener && list[i].listener === listener)) {\r\n\t    position = i;\r\n\t    break;\r\n\t   }\r\n\t  }\r\n\t\r\n\t  if (position < 0)\r\n\t   return this;\r\n\t\r\n\t  if (list.length === 1) {\r\n\t   list.length = 0;\r\n\t   delete this._events[type];\r\n\t  } else {\r\n\t   list.splice(position, 1);\r\n\t  }\r\n\t\r\n\t  if (this._events.removeListener)\r\n\t   this.emit('removeListener', type, listener);\r\n\t }\r\n\t\r\n\t return this;\r\n\t};\r\n\t\r\n\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\r\n\t\r\n\tEventEmitter.prototype.removeAllListeners = function(type) {\r\n\t var key, listeners;\r\n\t\r\n\t if (!this._events)\r\n\t  return this;\r\n\t\r\n\t // not listening for removeListener, no need to emit\r\n\t if (!this._events.removeListener) {\r\n\t  if (arguments.length === 0)\r\n\t   this._events = {};\r\n\t  else if (this._events[type])\r\n\t   delete this._events[type];\r\n\t  return this;\r\n\t }\r\n\t\r\n\t // emit removeListener for all listeners on all events\r\n\t if (arguments.length === 0) {\r\n\t  for (key in this._events) {\r\n\t   if (key === 'removeListener') continue;\r\n\t   this.removeAllListeners(key);\r\n\t  }\r\n\t  this.removeAllListeners('removeListener');\r\n\t  this._events = {};\r\n\t  return this;\r\n\t }\r\n\t\r\n\t listeners = this._events[type];\r\n\t\r\n\t if (isFunction(listeners)) {\r\n\t  this.removeListener(type, listeners);\r\n\t } else {\r\n\t  // LIFO order\r\n\t  while (listeners.length)\r\n\t   this.removeListener(type, listeners[listeners.length - 1]);\r\n\t }\r\n\t delete this._events[type];\r\n\t\r\n\t return this;\r\n\t};\r\n\t\r\n\tEventEmitter.prototype.listeners = function(type) {\r\n\t var ret;\r\n\t if (!this._events || !this._events[type])\r\n\t  ret = [];\r\n\t else if (isFunction(this._events[type]))\r\n\t  ret = [this._events[type]];\r\n\t else\r\n\t  ret = this._events[type].slice();\r\n\t return ret;\r\n\t};\r\n\t\r\n\tEventEmitter.listenerCount = function(emitter, type) {\r\n\t var ret;\r\n\t if (!emitter._events || !emitter._events[type])\r\n\t  ret = 0;\r\n\t else if (isFunction(emitter._events[type]))\r\n\t  ret = 1;\r\n\t else\r\n\t  ret = emitter._events[type].length;\r\n\t return ret;\r\n\t};\r\n\t\r\n\tfunction isFunction(arg) {\r\n\t return typeof arg === 'function';\r\n\t}\r\n\t\r\n\tfunction isNumber(arg) {\r\n\t return typeof arg === 'number';\r\n\t}\r\n\t\r\n\tfunction isObject(arg) {\r\n\t return typeof arg === 'object' && arg !== null;\r\n\t}\r\n\t\r\n\tfunction isUndefined(arg) {\r\n\t return arg === void 0;\r\n\t}\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util = __webpack_require__(5);\r\n\tvar props = util.props;\r\n\tvar Application = __webpack_require__(6);\r\n\tvar Channel = __webpack_require__(7);\r\n\t\r\n\t\r\n\t/**\r\n\t * A Service instance represents the multiscreen service root on the remote device\r\n\t * Use the class to control top level services of the device\r\n\t *\r\n\t * @namespace Service\r\n\t *\r\n\t */\r\n\t\r\n\tfunction Service(description){\r\n\t\r\n\t    /**\r\n\t     * The id of the service\r\n\t     *\r\n\t     * @member {String} Service#id\r\n\t     * @readonly\r\n\t     */\r\n\t    this.id = description.id;\r\n\t\r\n\t    /**\r\n\t     * The name of the service (Living Room TV)\r\n\t     *\r\n\t     * @member {String} Service#name\r\n\t     * @readonly\r\n\t     */\r\n\t    this.name = description.name;\r\n\t\r\n\t    /**\r\n\t     * The version of the service (x.x.x)\r\n\t     *\r\n\t     * @member {String} Service#version\r\n\t     * @readonly\r\n\t     */\r\n\t    this.version = description.version;\r\n\t\r\n\t    /**\r\n\t     * The type of the service (Samsung SmartTV)\r\n\t     *\r\n\t     * @member {String} Service#type\r\n\t     * @readonly\r\n\t     */\r\n\t    this.type = description.type;\r\n\t\r\n\t    /**\r\n\t     * The uri of the service (http://<ip>:<port>/api/v2/)\r\n\t     *\r\n\t     * @member {String} Service#uri\r\n\t     * @readonly\r\n\t     */\r\n\t    this.uri = description.uri;\r\n\t\r\n\t    /**\r\n\t     * A hash of additional information about the device the service is running on\r\n\t     *\r\n\t     * @member {String} Service#device\r\n\t     * @readonly\r\n\t     */\r\n\t    this.device = description.device;\r\n\t\r\n\t    props.readOnly(this,['id','name','version','type','uri','device']);\r\n\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * Factory method for creating application instances belonging to that service\r\n\t *\r\n\t * @param {String} id An installed application id or url of the web application\r\n\t * @param {String} channelURI The uri the underlying channel will connect to.\r\n\t * @returns {Application}\r\n\t *\r\n\t */\r\n\tService.prototype.application = function(id, channelURI){\r\n\t\r\n\t    return new Application(this, id, channelURI);\r\n\t\r\n\t};\r\n\t\r\n\t/**\r\n\t * creates a channel of the service ('mychannel')\r\n\t *\r\n\t * @param {String} uri The uri of the Channel\r\n\t * @returns {Channel}\r\n\t */\r\n\tService.prototype.channel = function(uri){\r\n\t\r\n\t    return new Channel(this, uri);\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/***\r\n\t * Retrieves a reference to the service running on the current device\r\n\t *\r\n\t * @protected\r\n\t *\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Error} callback.err The callback handler\r\n\t * @param {Service} callback.service The service instance\r\n\t *\r\n\t */\r\n\tService.getLocal = function(callback){\r\n\t\r\n\t    Service.getByURI('http://127.0.0.1:8001/api/v2/', callback);\r\n\t\r\n\t};\r\n\t\r\n\t/***\r\n\t * Retrieves a service instance by it's uri\r\n\t *\r\n\t * @protected\r\n\t *\r\n\t * @param {String} uri The uri of the service (http://<ip>:<port>/api/v2/)\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Error} callback.err The callback handler\r\n\t * @param {Service} callback.service The service instance\r\n\t *\r\n\t */\r\n\tService.getByURI = function(uri, callback){\r\n\t\r\n\t    var oReq = new XMLHttpRequest();\r\n\t    oReq.timeout = 5000;\r\n\t    oReq.ontimeout = function(){callback();};\r\n\t    oReq.onload = function() {\r\n\t\r\n\t        if(this.status === 200){\r\n\t            try{\r\n\t                var result = JSON.parse(this.responseText);\r\n\t                callback(null, new Service(result));\r\n\t            }catch(e){  callback(e); }\r\n\t        }else{\r\n\t            callback();\r\n\t        }\r\n\t    };\r\n\t    oReq.open(\"get\", uri, true);\r\n\t    oReq.send();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tmodule.exports = Service;\r\n\t\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util = __webpack_require__(5);\r\n\tvar props = util.props;\r\n\tvar EventEmitter = __webpack_require__(2);\r\n\t\r\n\t\r\n\t/**\r\n\t * Provides facilities to stop and start multiscreen service searches.\r\n\t *\r\n\t * @namespace Search\r\n\t * @extends EventEmitter\r\n\t *\r\n\t */\r\n\t\r\n\tfunction Search(){\r\n\t\r\n\t\r\n\t    Search.super_.call(this);\r\n\t\r\n\t    this.discoveryFrame = null;\r\n\t    this.status = Search.STATUS_STOPPED;\r\n\t\r\n\t    var self = this;\r\n\t\r\n\t    /* Create the discovery iframe and load the search page */\r\n\t\r\n\t    var frame = document.createElement('iframe');\r\n\t    frame.setAttribute('width', '1');\r\n\t    frame.setAttribute('height', '1');\r\n\t    frame.style.display = \"none\";\r\n\t    frame.src = 'http://multiscreen.samsung.com/discoveryservice/v2/discover';\r\n\t    document.body.appendChild(frame);\r\n\t\r\n\t    /* Add a 'message' listener to the window that checks incoming messages */\r\n\t\r\n\t    this.windowMessageListener = function(event){\r\n\t\r\n\t        if(event.source === frame.contentWindow){\r\n\t\r\n\t            // ready message\r\n\t            if(event.data && event.data.event === 'discovery.ready'){\r\n\t                self.discoveryFrame = event.source;\r\n\t                self.onSearchReady();\r\n\t            }\r\n\t\r\n\t            // result message\r\n\t            else if(event.data && event.data.event === 'discovery.result'){\r\n\t                var results = [];\r\n\t                var Service = __webpack_require__(3);\r\n\t                for(var i=0; i<event.data.result.length; i++){\r\n\t                    results.push(new Service(event.data.result[i]));\r\n\t                }\r\n\t                self.onSearchResult(results);\r\n\t            }\r\n\t\r\n\t            // error message\r\n\t            else if(event.data && event.data.event === 'discovery.error'){\r\n\t                self.onSearchError(event.data.error);\r\n\t                this.status = Search.STATUS_STOPPED;\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    window.addEventListener('message', this.windowMessageListener);\r\n\t\r\n\t    props.private(this,['discoveryFrame','windowMessageListener']);\r\n\t\r\n\t}\r\n\t\r\n\tutil.inherits(Search, EventEmitter);\r\n\t\r\n\t\r\n\t/***\r\n\t * @constant {string}\r\n\t * @private\r\n\t */\r\n\tSearch.STATUS_STOPPED = 'stopped';\r\n\t\r\n\t/***\r\n\t * @constant {string}\r\n\t * @private\r\n\t */\r\n\tSearch.STATUS_STARTED = 'started';\r\n\t\r\n\t/***\r\n\t * @private\r\n\t */\r\n\tSearch.prototype.onSearchReady = function(){\r\n\t    this.emit('ready');\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t/**\r\n\t * Fired when a search has discovered compatible services\r\n\t *\r\n\t * @event Search#found\r\n\t * @type {Array}\r\n\t */\r\n\t\r\n\t/***\r\n\t * @private\r\n\t */\r\n\tSearch.prototype.onSearchResult = function(results){\r\n\t    if(this.status !== Search.STATUS_STOPPED){\r\n\t        this.emit('found',results);\r\n\t    }\r\n\t    this.status = Search.STATUS_STOPPED;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Fired when a search error has occurred\r\n\t *\r\n\t * @event Search#error\r\n\t * @type {Error}\r\n\t */\r\n\t\r\n\t/***\r\n\t * @private\r\n\t */\r\n\tSearch.prototype.onSearchError = function(error){\r\n\t    this.emit('error',error);\r\n\t    this.status = Search.STATUS_STOPPED;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Starts the search, looking for devices it can reach on the local network\r\n\t * If a search is already in progress it will NOT begin a new search\r\n\t */\r\n\tSearch.prototype.start = function(){\r\n\t    if(this.status === Search.STATUS_STOPPED){\r\n\t        if(this.discoveryFrame){\r\n\t            this.discoveryFrame.postMessage({method:'discovery.search'}, \"*\");\r\n\t        }else{\r\n\t            var self = this;\r\n\t            this.once('ready',function(){\r\n\t                self.discoveryFrame.postMessage({method:'discovery.search'}, \"*\");\r\n\t            });\r\n\t        }\r\n\t\r\n\t        this.status = Search.STATUS_STARTED;\r\n\t        /**\r\n\t         * Fired when a search has been started\r\n\t         *\r\n\t         * @event Search#start\r\n\t         * @type {Search}\r\n\t         */\r\n\t        this.emit('start', this);\r\n\t    }else{\r\n\t        console.warn('a previous search is already in progress');\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * Stops the current search in progress (no 'found' events or search callbacks will fire)\r\n\t */\r\n\tSearch.prototype.stop = function(){\r\n\t    this.status = Search.STATUS_STOPPED;\r\n\t    /**\r\n\t     * Fired when a search has been stopped\r\n\t     *\r\n\t     * @event Search#stop\r\n\t     * @type {Search}\r\n\t     */\r\n\t    this.emit('stop', this);\r\n\t};\r\n\t\r\n\t\r\n\tmodule.exports = Search;\r\n\t\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = {\r\n\t\r\n\t    url         : __webpack_require__(8),\r\n\t    inherits    : __webpack_require__(9),\r\n\t    props       : __webpack_require__(10),\r\n\t    types       : __webpack_require__(11),\r\n\t    queryString : __webpack_require__(12)\r\n\t\r\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util = __webpack_require__(5);\r\n\tvar types = util.types;\r\n\tvar props = util.props;\r\n\tvar Channel = __webpack_require__(7);\r\n\t\r\n\t\r\n\t/**\r\n\t * An Application represents an application on the local or remote device.\r\n\t * Use the class to control various aspects of the application such launching the app or getting information\r\n\t *\r\n\t * @namespace Application\r\n\t * @extends Channel\r\n\t *\r\n\t */\r\n\t\r\n\tfunction Application(service, id, channelURI){\r\n\t\r\n\t    /* Type checking */\r\n\t    if(!types.isObject(service)) throw new TypeError('service must be of type Service');\r\n\t    if(!types.isString(id)) throw new TypeError('id must be a valid string');\r\n\t    if(!types.isString(channelURI)) throw new TypeError('channelId must be a valid string');\r\n\t\r\n\t    /***\r\n\t     * The type of application (web application or installable app)\r\n\t     * @member {String} Application#type\r\n\t     * @private\r\n\t     */\r\n\t    this.type = id.match(/(file:\\/\\/|http(s)?:\\/\\/)/gmi) ? 'webapplication' : 'application';\r\n\t\r\n\t    /* Super Constructor */\r\n\t    Application.super_.call(this, service, channelURI);\r\n\t\r\n\t\r\n\t    /**\r\n\t     * The id of the application (this can be a url or installed application id)\r\n\t     * @member {String} Application#id\r\n\t     * @readonly\r\n\t     */\r\n\t    this.id = id;\r\n\t\r\n\t    /**\r\n\t     * Auto starts the application when connect is called\r\n\t     * This configuration property has no effect when used in a SmartTV application\r\n\t     *\r\n\t     * @member {Boolean} Application#startOnConnect\r\n\t     * @default [true]\r\n\t     * @example\r\n\t     * ```\r\n\t     * var app = service.application('myid');\r\n\t     * app.startOnConnect = false;\r\n\t     * app.connect(); // The application will not start on the TV\r\n\t     * ```\r\n\t     */\r\n\t    this.startOnConnect      = true;\r\n\t\r\n\t    /**\r\n\t     * Stops the application when disconnect is called and your client is the last client connected\r\n\t     * This configuration property has no effect when used in a SmartTV application\r\n\t     *\r\n\t     * @member {Boolean} Application#stopOnDisconnect\r\n\t     * @default [true]\r\n\t     * @example\r\n\t     * ```\r\n\t     * var app = service.application('myid');\r\n\t     * app.stopOnDisconnect = false;\r\n\t     * app.disconnect(); // The application will not close on the TV\r\n\t     * ```\r\n\t     */\r\n\t    this.stopOnDisconnect    = true;\r\n\t\r\n\t    /**\r\n\t     * Disconnects your client when the host connection ends (when the host application is exited)\r\n\t     * This configuration property has no effect when used in a SmartTV application\r\n\t     *\r\n\t     * @member {Boolean} Application#disconnectWithHost\r\n\t     * @default [true]\r\n\t     * @example\r\n\t     * ```\r\n\t     * app.on('clientDisconnect', function(client){\r\n\t     *    // client.isHost == true; but you will not be disconnected.\r\n\t     * });\r\n\t     * ```\r\n\t     */\r\n\t    this.disconnectWithHost  = true;\r\n\t\r\n\t\r\n\t    var self = this;\r\n\t\r\n\t    /* Listen for connect events and call start if startOnConnect */\r\n\t    this.on('connect', function(client){\r\n\t        if(self.startOnConnect && !self.clients.me.isHost) this.start();\r\n\t    });\r\n\t\r\n\t    /* Listen for clientDisconnect events and disconnect if host disconnects  */\r\n\t    this.on('clientDisconnect', function(client){\r\n\t        if(self.disconnectWithHost && client.isHost) this.disconnect();\r\n\t    });\r\n\t\r\n\t    /* Overwrite super disconnect and stop the app if stopOnDisconnect */\r\n\t    this.disconnect = function(callback){\r\n\t        if(self.stopOnDisconnect && self.clients.length < 3) {\r\n\t            self.stop(function(){\r\n\t                Channel.prototype.disconnect.call(self, callback);\r\n\t            });\r\n\t        }else{\r\n\t            Channel.prototype.disconnect.call(self, callback);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    props.readOnly(this,'id');\r\n\t    props.private(this,'type');\r\n\t\r\n\t}\r\n\t\r\n\tutil.inherits(Application, Channel);\r\n\t\r\n\t\r\n\t/**\r\n\t * Retrieves information about the Application on the remote device\r\n\t *\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Function} callback.err The callback handler\r\n\t * @param {Object} callback.result The callback handler\r\n\t *\r\n\t */\r\n\tApplication.prototype.getInfo = function(callback){\r\n\t\r\n\t    if(this.type === 'webapplication'){\r\n\t        this.invoke('ms.webapplication.get', { url: this.id }, callback);\r\n\t    }else{\r\n\t        this.invoke('ms.application.get', { id : this.id }, callback);\r\n\t    }\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Launches the application on the remote device\r\n\t *\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Function} callback.err The callback handler\r\n\t *\r\n\t */\r\n\tApplication.prototype.start = function(callback){\r\n\t\r\n\t    if(this.type === 'webapplication'){\r\n\t        this.invoke('ms.webapplication.start', { url : this.id }, callback);\r\n\t    }else{\r\n\t        this.invoke('ms.application.start', { id : this.id }, callback);\r\n\t    }\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Stop the application on the remote device\r\n\t *\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Function} callback.err The callback handler\r\n\t *\r\n\t */\r\n\tApplication.prototype.stop = function(callback){\r\n\t\r\n\t    if(this.type === 'webapplication'){\r\n\t        this.invoke('ms.webapplication.stop', { url : this.id }, callback);\r\n\t    }else{\r\n\t        this.invoke('ms.application.stop', { id : this.id }, callback);\r\n\t    }\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Installs the application on the remote device\r\n\t *\r\n\t * @param {Function} callback The callback handler\r\n\t * @param {Function} callback.err The callback handler\r\n\t *\r\n\t */\r\n\tApplication.prototype.install = function(callback){\r\n\t\r\n\t    if(this.type === 'webapplication') throw new Error('install cannot be called on web applications');\r\n\t    this.invoke('ms.application.install', { id : this.id }, callback);\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t\r\n\tmodule.exports = Application;\r\n\t\r\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util = __webpack_require__(5);\r\n\tvar types = util.types;\r\n\tvar props = util.props;\r\n\tvar EventEmitter = __webpack_require__(2);\r\n\tvar Client = __webpack_require__(13);\r\n\tvar ClientList = __webpack_require__(14);\r\n\t\r\n\t\r\n\t/**\r\n\t * A Channel is a discreet connection where multiple clients can communicate\r\n\t * @namespace Channel\r\n\t * @extends EventEmitter\r\n\t\r\n\t */\r\n\tfunction Channel(service, uri){\r\n\t\r\n\t    /* Type checking */\r\n\t    if(!types.isObject(service)) throw new TypeError('service must be of type Service');\r\n\t    if(!types.isString(uri)) throw new TypeError('uri must be a valid string');\r\n\t\r\n\t    /* Super Construction */\r\n\t    Channel.super_.call(this);\r\n\t\r\n\t    var self = this;\r\n\t    var oServiceUrl = util.url.parse(service.uri);\r\n\t\r\n\t    /**\r\n\t     * The uri of the channel ('chat')\r\n\t     *\r\n\t     * @member {String} Channel#uri\r\n\t     * @readonly\r\n\t     *\r\n\t     */\r\n\t    this.uri = uri;\r\n\t\r\n\t    /**\r\n\t     * The collection of clients currently connected to the channel\r\n\t     *\r\n\t     * @member {ClientList} Channel#clients\r\n\t     * @readonly\r\n\t     *\r\n\t     */\r\n\t    this.clients = new ClientList(this);\r\n\t\r\n\t    /**\r\n\t     * The connection status of the channel\r\n\t     *\r\n\t     * @member {Boolean} Channel#isConnected\r\n\t     * @readonly\r\n\t     *\r\n\t     */\r\n\t    Object.defineProperty(this, 'isConnected', {\r\n\t        get : function(){\r\n\t            return self.connection && self.connection.readyState === 1;\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /***\r\n\t     * The id assigned to your client upon connection\r\n\t     *\r\n\t     * @member {String} Channel#clientId\r\n\t     * @private\r\n\t     *\r\n\t     */\r\n\t    this.clientId = null;\r\n\t\r\n\t    /***\r\n\t     * The underlying web socket connection\r\n\t     *\r\n\t     * @member {WebSocket} Channel#connection\r\n\t     * @private\r\n\t     *\r\n\t     */\r\n\t    this.connection = null;\r\n\t\r\n\t    /***\r\n\t     * A map of message handler still waiting for responses\r\n\t     *\r\n\t     * @member {Object} Channel#resultHandlers\r\n\t     * @private\r\n\t     *\r\n\t     */\r\n\t    this.resultHandlers = {};\r\n\t\r\n\t    /***\r\n\t     * The url for the websocket to connect to\r\n\t     *\r\n\t     * @member {Object} Channel#connectionUrl\r\n\t     * @private\r\n\t     *\r\n\t     */\r\n\t    this.connectionUrl = 'ws://' + oServiceUrl.host + oServiceUrl.pathname + 'channels/' + uri;\r\n\t\r\n\t\r\n\t    props.private(this, ['clientId','connection','resultHandlers','connectionUrl']);\r\n\t    props.readOnly(this, ['uri','clients']);\r\n\t}\r\n\t\r\n\t\r\n\tutil.inherits(Channel, EventEmitter);\r\n\t\r\n\t\r\n\t/*\r\n\t Packs messages with payloads into binary message\r\n\t */\r\n\tChannel.packMessage = function(oMsg, payload){\r\n\t\r\n\t    // convert js object to string\r\n\t    var msg = JSON.stringify(oMsg);\r\n\t\r\n\t    // get byte length of the string\r\n\t    var msgByteLength = new Blob([msg]).size;\r\n\t\r\n\t    // create 2 byte header which contains the length of the string (json) message\r\n\t    var hBuff = new ArrayBuffer(2);\r\n\t    var hView = new DataView(hBuff);\r\n\t    hView.setUint16(0,msgByteLength);\r\n\t\r\n\t    // binary packed message and payload\r\n\t    return new Blob([hBuff, msg, payload]);\r\n\t\r\n\t};\r\n\t\r\n\t/*\r\n\t Unpacks binary messages\r\n\t */\r\n\tChannel.unpackMessage = function(buffer){\r\n\t\r\n\t    var json = '';\r\n\t    var view = new DataView(buffer);\r\n\t    var msgByteLen = view.getUint16(0);\r\n\t\r\n\t    for (var i = 0; i < msgByteLen; i++) {\r\n\t        json += String.fromCharCode(view.getUint8(i+2));\r\n\t    }\r\n\t\r\n\t    var payload = buffer.slice(2+msgByteLen);\r\n\t    var message = JSON.parse(json);\r\n\t\r\n\t    return {payload : payload, message : message};\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/***\r\n\t * Invokes and RPC method on the server\r\n\t *\r\n\t * @protected\r\n\t *\r\n\t * @param {String} method The name of the method to invoke\r\n\t * @param {Object} params Named params to pass to the method\r\n\t * @param {Function} [callback] The success callback handler\r\n\t * @param {Error} callback.error Any error that may have occurred\r\n\t * @param {Boolean} callback.success\r\n\t * @param {Boolean} [isNotification=false] If true the message will have no id and no response handler will be stored\r\n\t * @param {ArrayBuffer|Blob} [payload] Any binary data to send along with the message\r\n\t *\r\n\t */\r\n\tChannel.prototype.invoke = function(method, params, callback, isNotification, payload){\r\n\t\r\n\t    if(!this.isConnected) throw new Error(\"the channel is disconnected\");\r\n\t    if(!types.isString(method))throw new TypeError('method must be a valid string');\r\n\t\r\n\t    params = params || {};\r\n\t\r\n\t    var msg = {\r\n\t        method  : method,\r\n\t        params  : params\r\n\t    };\r\n\t\r\n\t    if(callback && !isNotification){\r\n\t        msg.id = Date.now();\r\n\t        this.resultHandlers[msg.id] = callback;\r\n\t    }\r\n\t\r\n\t    if(payload){\r\n\t        msg = Channel.packMessage(msg,payload);\r\n\t    }else{\r\n\t        msg = JSON.stringify(msg);\r\n\t    }\r\n\t\r\n\t    this.connection.send(msg);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Connects to the channel\r\n\t *\r\n\t * @param {Object} attributes Any attributes you want to associate with the client (ie. {name:\"FooBar\"}\r\n\t * @param {Function} callback The success callback handler\r\n\t * @param {Error} callback.error Any error that may have occurred\r\n\t * @param {Channel} callback.channel The channel instance that connected\r\n\t *\r\n\t */\r\n\tChannel.prototype.connect = function(attributes, callback){\r\n\t\r\n\t    if(types.isFunction(attributes) && !callback){\r\n\t        callback = attributes;\r\n\t        attributes = {};\r\n\t    }else{\r\n\t        attributes = attributes || {};\r\n\t    }\r\n\t\r\n\t    // Validate arguments and connection state\r\n\t    if(!types.isObject(attributes))throw new TypeError('attributes must be a valid object');\r\n\t    if(callback && !types.isFunction(callback))throw new TypeError('callback must be a valid function');\r\n\t    if(this.isConnected) return console.warn('Channel is already connected.');\r\n\t\r\n\t    // TODO : Need to merge query string just in case the connection url already has a query (although it shouldn't)\r\n\t    var u = this.connectionUrl + '?' + util.queryString.stringify(attributes);\r\n\t\r\n\t    // Connect the websocket and add our listeners\r\n\t    if(!this.connection){\r\n\t        this.connection = new WebSocket(u);\r\n\t        this.connection.binaryType = \"arraybuffer\";\r\n\t        this.connection.onopen = this._onSocketOpen.bind(this);\r\n\t        this.connection.onerror = this._onSocketError.bind(this);\r\n\t        this.connection.onclose = this._onSocketClose.bind(this);\r\n\t        this.connection.onmessage = this._onSocketMessage.bind(this);\r\n\t    }\r\n\t\r\n\t    // Listen once for connect if there was a callback\r\n\t    var self = this;\r\n\t    if(callback){\r\n\t        this.once('connect', function(client){\r\n\t            callback(null, self);\r\n\t        });\r\n\t    }\r\n\t\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Disconnects from the channel\r\n\t *\r\n\t * @param {Function} callback The success callback handler\r\n\t * @param {Error} callback.error Any error that may have occurred\r\n\t * @param {Channel} callback.channel The channel instance\r\n\t *\r\n\t */\r\n\tChannel.prototype.disconnect = function(callback){\r\n\t\r\n\t    if(!this.isConnected) throw new Error(\"the channel is already disconnected\");\r\n\t    this.connection.close();\r\n\t    var self = this;\r\n\t    setTimeout(function(){\r\n\t        if(callback) callback(null, self);\r\n\t    },0);\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Publish an event message to the specified target or targets.\r\n\t * Targets can be in the for of a clients id, an array of client ids or one of the special message target strings (ie. \"all\" or \"host\"}\r\n\t *\r\n\t * @param {String} event The name of the event to emit\r\n\t * @param {any} [message] Any data associated with the event\r\n\t * @param {String|Array} [target='broadcast'] The target recipient(s) of the message\r\n\t * @param {Blob|ArrayBuffer} [payload] Any binary data to send with the message\r\n\t *\r\n\t */\r\n\tChannel.prototype.publish = function(event, message, target, payload){\r\n\t\r\n\t    target = target || 'broadcast';\r\n\t    message = message || null;\r\n\t\r\n\t    if(!this.isConnected) throw new Error(\" the channel is not connected\");\r\n\t    if(!types.isString(event))throw new TypeError('event must be a valid string');\r\n\t\r\n\t    if(!(types.isString(target) || types.isArray(target))) throw new TypeError('targets must be a valid string or array');\r\n\t\r\n\t    this.invoke('ms.channel.emit',{\r\n\t        event   : event,\r\n\t        data    : message,\r\n\t        to      : target\r\n\t    }, null, true, payload);\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t// TODO : Make these non enumerable\r\n\t\r\n\t\r\n\tChannel.prototype._onSocketOpen = function() {\r\n\t    // nothing to do here for now\r\n\t};\r\n\t\r\n\tChannel.prototype._onSocketClose = function() {\r\n\t    /**\r\n\t     * Fired when a channel disconnects\r\n\t     *\r\n\t     * @event Channel#disconnect\r\n\t     * @type {Client}\r\n\t     */\r\n\t    var client = this.clients.me;\r\n\t    this.clients.clear();\r\n\t    this.emit('disconnect',client);\r\n\t};\r\n\t\r\n\tChannel.prototype._onSocketError = function() {\r\n\t    this.emit('error', new Error(\"WebSocket error\"));\r\n\t};\r\n\t\r\n\t\r\n\tChannel.prototype._onSocketMessage = function(msg){\r\n\t\r\n\t    var client;\r\n\t    var payload;\r\n\t\r\n\t    try{\r\n\t        if(typeof msg.data === \"string\"){\r\n\t            msg = JSON.parse(msg.data);\r\n\t        }else{\r\n\t            var unpacked = Channel.unpackMessage(msg.data);\r\n\t            msg = unpacked.message;\r\n\t            payload = unpacked.payload;\r\n\t        }\r\n\t    } catch (e) {\r\n\t        console.warn('unable to parse message', msg);\r\n\t        return;\r\n\t    }\r\n\t\r\n\t    if(msg.id && (msg.result || msg.error)){\r\n\t\r\n\t        if(!this.resultHandlers[msg.id]){\r\n\t            console.warn('unable to find result handler for result message ', msg);\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        this.resultHandlers[msg.id](msg.error,msg.result);\r\n\t\r\n\t    }else if (msg.event){\r\n\t\r\n\t        switch(msg.event){\r\n\t\r\n\t            case 'ms.channel.connect' :\r\n\t\r\n\t                // Store my id\r\n\t                this.clientId = msg.data.id;\r\n\t\r\n\t                // Store the current connected client\r\n\t                msg.data.clients.forEach(function(clientInfo){\r\n\t\r\n\t                    // Create a client and add to our list\r\n\t                    client = new Client(clientInfo.id, clientInfo.attributes, clientInfo.isHost);\r\n\t                    this.clients.push(client);\r\n\t\r\n\t                },this);\r\n\t\r\n\t                /**\r\n\t                 * Fired when a channel makes a connection\r\n\t                 *\r\n\t                 * @event Channel#connect\r\n\t                 * @type {Client}\r\n\t                 */\r\n\t                this.emit('connect',this.clients.me);\r\n\t\r\n\t                break;\r\n\t\r\n\t            case 'ms.channel.clientConnect' :\r\n\t\r\n\t                client = new Client(msg.data.id, msg.data.attributes, msg.data.isHost);\r\n\t                this.clients.push(client);\r\n\t\r\n\t                /**\r\n\t                 * Fired when a peer client channel makes a connection\r\n\t                 *\r\n\t                 * @event Channel#clientConnect\r\n\t                 * @type {Client}\r\n\t                 */\r\n\t\r\n\t                this.emit('clientConnect',client);\r\n\t                break;\r\n\t\r\n\t            case 'ms.channel.clientDisconnect' :\r\n\t\r\n\t                client = this.clients.getById(msg.data.id);\r\n\t                if(client) this.clients.remove(client);\r\n\t                else {\r\n\t                    console.warn('client '+msg.data.id+' could not be found, so it was not removed from the client list');\r\n\t                    client = new Client(msg.data.id, msg.data.attributes, msg.data.isHost);\r\n\t                }\r\n\t\r\n\t                /**\r\n\t                 * Fired when a peer client disconnects\r\n\t                 *\r\n\t                 * @event Channel#clientDisconnect\r\n\t                 * @type {Client}\r\n\t                 */\r\n\t                this.emit('clientDisconnect',client);\r\n\t                break;\r\n\t\r\n\t            case 'ms.channel.ready' :\r\n\t\r\n\t\r\n\t                /**\r\n\t                 * Convenience event indicating the host has connected and is ready to accept messages\r\n\t                 *\r\n\t                 * @event Channel#ready\r\n\t                 */\r\n\t                this.emit('ready');\r\n\t                break;\r\n\t\r\n\t\r\n\t            default :\r\n\t\r\n\t                client = this.clients.getById(msg.from);\r\n\t                var event = msg.event;\r\n\t                var data  = msg.data;\r\n\t\r\n\t                this.emit(event, data, client, payload);\r\n\t                break;\r\n\t\r\n\t        }\r\n\t\r\n\t    }else{\r\n\t        console.warn('unrecognized message type', msg);\r\n\t    }\r\n\t\r\n\t};\r\n\t\r\n\tmodule.exports = Channel;\r\n\t\r\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar queryString = __webpack_require__(12);\r\n\t\r\n\tvar url = {\r\n\t\r\n\t    isValid : function(u){\r\n\t\r\n\t        var pattern = /^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/;\r\n\t        return u.match(pattern) ? true : false;\r\n\t    },\r\n\t\r\n\t    parse : function(u){\r\n\t\r\n\t        var oUrl = {};\r\n\t        var parser = document.createElement('a');\r\n\t        parser.href = u; // \"http://example.com:3000/pathname/?search=test#hash\";\r\n\t\r\n\t        oUrl.href = parser.href; // => \"http://ip:port/path/page?query=string#hash\"\r\n\t        oUrl.protocol = parser.protocol; // => \"http:\"\r\n\t        oUrl.hostname = parser.hostname; // => \"example.com\"\r\n\t        oUrl.port = parser.port;     // => \"3000\"\r\n\t        oUrl.pathname = parser.pathname; // => \"/pathname/\"\r\n\t        oUrl.search = parser.search;   // => \"?search=test\"\r\n\t        oUrl.hash = parser.hash;     // => \"#hash\"\r\n\t        oUrl.host = parser.host;     // => \"example.com:3000\"\r\n\t        oUrl.queryString = queryString.parse(parser.search);\r\n\t\r\n\t        return oUrl;\r\n\t    }\r\n\t\r\n\t\r\n\t};\r\n\t\r\n\tmodule.exports = url;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tif (typeof Object.create === 'function') {\r\n\t    // implementation from standard node.js 'util' module\r\n\t    module.exports = function inherits(ctor, superCtor) {\r\n\t        ctor.super_ = superCtor;\r\n\t        ctor.prototype = Object.create(superCtor.prototype, {\r\n\t            constructor: {\r\n\t                value: ctor,\r\n\t                enumerable: false,\r\n\t                writable: true,\r\n\t                configurable: true\r\n\t            }\r\n\t        });\r\n\t    };\r\n\t} else {\r\n\t    // old school shim for old browsers\r\n\t    module.exports = function inherits(ctor, superCtor) {\r\n\t        ctor.super_ = superCtor;\r\n\t        var TempCtor = function () {};\r\n\t        TempCtor.prototype = superCtor.prototype;\r\n\t        ctor.prototype = new TempCtor();\r\n\t        ctor.prototype.constructor = ctor;\r\n\t    };\r\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tfunction createDescriptor(e,c,w,v){\r\n\t    return {\r\n\t        enumerable : e,\r\n\t        configurable : c,\r\n\t        writable : w,\r\n\t        value : v\r\n\t    };\r\n\t}\r\n\t\r\n\tmodule.exports = {\r\n\t\r\n\t    readOnly : function(obj, key){\r\n\t\r\n\t        if(Array.isArray(key)){\r\n\t            key.forEach(function(k){\r\n\t                Object.defineProperty(obj, k, createDescriptor(true,true,false,obj[k]));\r\n\t            });\r\n\t        }else{\r\n\t            Object.defineProperty(obj, key, createDescriptor(true,true,false,obj[key]));\r\n\t        }\r\n\t\r\n\t    },\r\n\t\r\n\t    private : function(obj, key){\r\n\t\r\n\t        if(Array.isArray(key)){\r\n\t            key.forEach(function(k){ Object.defineProperty(obj, k, createDescriptor(false,true,true,obj[k])); });\r\n\t        }else{\r\n\t            Object.defineProperty(obj, key, createDescriptor(false,true,true,obj[key]));\r\n\t        }\r\n\t    }\r\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tmodule.exports = {\r\n\t\r\n\t    isString : function(obj){\r\n\t        return typeof obj === 'string';\r\n\t    },\r\n\t\r\n\t    isNull : function(obj){\r\n\t        return obj === null;\r\n\t    },\r\n\t\r\n\t    isBoolean : function(obj){\r\n\t        return typeof obj === 'boolean';\r\n\t    },\r\n\t\r\n\t    isNumber : function(obj){\r\n\t        return typeof obj === 'number';\r\n\t    },\r\n\t\r\n\t    isObject : function(obj){\r\n\t        return obj === Object(obj);\r\n\t    },\r\n\t\r\n\t    isArray : function(obj){\r\n\t        return obj.constructor === Array;\r\n\t    },\r\n\t\r\n\t    isFunction : function(obj){\r\n\t        return typeof obj === 'function';\r\n\t    }\r\n\t\r\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\r\n\t\r\n\t/*\r\n\t    Derived work from Sidre Sorhus (https://github.com/sindresorhus/query-string)\r\n\t */\r\n\t\r\n\t/*!\r\n\t query-string\r\n\t Parse and stringify URL query strings\r\n\t https://github.com/sindresorhus/query-string\r\n\t by Sindre Sorhus\r\n\t MIT License\r\n\t */\r\n\t\r\n\tvar queryString = {};\r\n\t\r\n\tqueryString.parse = function (str) {\r\n\t    if (typeof str !== 'string') {\r\n\t        return {};\r\n\t    }\r\n\t\r\n\t    str = str.trim().replace(/^(\\?|#)/, '');\r\n\t\r\n\t    if (!str) {\r\n\t        return {};\r\n\t    }\r\n\t\r\n\t    return str.trim().split('&').reduce(function (ret, param) {\r\n\t        var parts = param.replace(/\\+/g, ' ').split('=');\r\n\t        var key = parts[0];\r\n\t        var val = parts[1];\r\n\t\r\n\t        key = decodeURIComponent(key);\r\n\t        // missing `=` should be `null`:\r\n\t        // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\r\n\t        val = val === undefined ? null : decodeURIComponent(val);\r\n\t\r\n\t        if (!ret.hasOwnProperty(key)) {\r\n\t            ret[key] = val;\r\n\t        } else if (Array.isArray(ret[key])) {\r\n\t            ret[key].push(val);\r\n\t        } else {\r\n\t            ret[key] = [ret[key], val];\r\n\t        }\r\n\t\r\n\t        return ret;\r\n\t    }, {});\r\n\t};\r\n\t\r\n\tqueryString.stringify = function (obj) {\r\n\t    return obj ? Object.keys(obj).map(function (key) {\r\n\t        var val = obj[key];\r\n\t\r\n\t        if (Array.isArray(val)) {\r\n\t            return val.map(function (val2) {\r\n\t                return encodeURIComponent(key) + '=' + encodeURIComponent(val2);\r\n\t            }).join('&');\r\n\t        }\r\n\t\r\n\t        return encodeURIComponent(key) + '=' + encodeURIComponent(val);\r\n\t    }).join('&') : '';\r\n\t};\r\n\t\r\n\tmodule.exports = queryString;\r\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util = __webpack_require__(5);\r\n\tvar types = util.types;\r\n\t\r\n\t\r\n\t/**\r\n\t * @namespace Client\r\n\t *\r\n\t */\r\n\tfunction ChannelClient(id, attributes, isHost, connectTime){\r\n\t\r\n\t    if(!types.isString(id)) throw new TypeError('id must be a valid string');\r\n\t    if(attributes && !types.isObject(attributes)) throw new TypeError('attributes must be a valid object');\r\n\t\r\n\t    /**\r\n\t     * The id of the client\r\n\t     *\r\n\t     * @name id\r\n\t     * @memberOf Client.prototype\r\n\t     * @type {String}\r\n\t     * @readonly\r\n\t     *\r\n\t     */\r\n\t    this.id = id;\r\n\t\r\n\t    /**\r\n\t     * A map of attributes passed by the client when connecting\r\n\t     *\r\n\t     * @name attributes\r\n\t     * @memberOf Client.prototype\r\n\t     * @type {Object}\r\n\t     * @readonly\r\n\t     *\r\n\t     */\r\n\t    this.attributes = attributes || {};\r\n\t\r\n\t    /**\r\n\t     * Flag for determining if the client is the host\r\n\t     *\r\n\t     * @name isHost\r\n\t     * @memberOf Client.prototype\r\n\t     * @type {Boolean}\r\n\t     * @readonly\r\n\t     *\r\n\t     */\r\n\t    this.isHost = isHost;\r\n\t\r\n\t    /**\r\n\t     * The time which the client connected in epoch milliseconds\r\n\t     *\r\n\t     * @name connectTime\r\n\t     * @memberOf Client.prototype\r\n\t     * @type {Number}\r\n\t     * @readonly\r\n\t     *\r\n\t     */\r\n\t    this.connectTime = connectTime || Date.now();\r\n\t\r\n\t    Object.freeze(this.attributes);\r\n\t    Object.freeze(this);\r\n\t\r\n\t}\r\n\t\r\n\tmodule.exports = ChannelClient;\r\n\t\r\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\tvar util = __webpack_require__(5);\r\n\tvar types = util.types;\r\n\t\r\n\t/**\r\n\t * A list of clients\r\n\t * @namespace ClientList\r\n\t * @extends Array\r\n\t */\r\n\t\r\n\tfunction ClientList(channel){\r\n\t\r\n\t    if(!types.isObject(channel))throw new TypeError('channel must be of type Channel');\r\n\t\r\n\t    this.channel = channel;\r\n\t\r\n\t    ClientList.super_.call(this);\r\n\t\r\n\t}\r\n\t\r\n\tutil.inherits(ClientList, Array);\r\n\t\r\n\t/***\r\n\t * Clears the list\r\n\t * @protected\r\n\t */\r\n\tClientList.prototype.clear = function(){\r\n\t    this.length = 0;\r\n\t};\r\n\t\r\n\t/***\r\n\t * Removes an client from the list\r\n\t * @protected\r\n\t */\r\n\tClientList.prototype.remove = function(item){\r\n\t    var i = this.indexOf(item);\r\n\t    if(i !== -1) {\r\n\t        this.splice(i, 1);\r\n\t        return item;\r\n\t    }\r\n\t    return null;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Returns a client by id\r\n\t *\r\n\t * @param {String} id The client\r\n\t * @return {Client}\r\n\t *\r\n\t */\r\n\tClientList.prototype.getById = function(id){\r\n\t\r\n\t    if(!types.isString(id) && !types.isNumber(id)) throw new TypeError('id must be a valid string or number');\r\n\t    for(var i=0; i<this.length; i++){\r\n\t        if(this[i].id === id) return this[i];\r\n\t    }\r\n\t    return null;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * A reference to your client\r\n\t *\r\n\t * @member {Client} ClientList#me\r\n\t * @readonly\r\n\t */\r\n\tObject.defineProperty(ClientList.prototype, 'me', {\r\n\t    get : function(){\r\n\t        return this.getById(this.channel.clientId);\r\n\t    }\r\n\t});\r\n\t\r\n\t\r\n\tmodule.exports = ClientList;\r\n\t\r\n\n\n/***/ }\n/******/ ])\n\n\n/** WEBPACK FOOTER **\n ** msf-2.0.9.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ac564d9e737f1af9e4c3\n **/","\"use strict\";\r\n\r\nvar msf = require('./lib/msf');\r\n\r\nif (typeof define === 'function' && define.amd) {\r\n    define(function() { return msf; });\r\n} else if (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = msf;\r\n} else {\r\n    window.msf = msf;\r\n}\r\n\r\nmodule.exports = msf;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util = require(\"./util\");\r\nvar EventEmitter = require('./EventEmitter');\r\nvar Service = require('./Service');\r\nvar Search = require('./Search');\r\n\r\n// We will use a singleton for search so that we don't create multiple frames in the page\r\nvar search = null;\r\n\r\n\r\n/**\r\n * The entry point for the API\r\n *\r\n * @namespace msf\r\n * @type {EventEmitter}\r\n *\r\n */\r\nvar msf = new EventEmitter();\r\n\r\n\r\n/**\r\n * Searches the local network for compatible multiscreen services\r\n *\r\n * @param {Function} [callback] If a callback is passed the search is immediately started.\r\n * @param {Error} callback.err The callback handler\r\n * @param {Array} callback.result An array of {@link Service} instances found on the network\r\n * @returns {Search} A search instance (a singleton is used to reduce page resources)\r\n *\r\n */\r\nmsf.search = function(callback){\r\n\r\n    // Create the single instance if we don't already have one\r\n    if(!search) search = new Search();\r\n\r\n    // If there is a callback defined, listen once for results and start the search\r\n    if(callback) {\r\n        search.once('found',function(services){\r\n            callback(null, services);\r\n        });\r\n\r\n        // start on next tick to support search callbacks and events\r\n        setTimeout(function(){ search.start(); },0);\r\n\r\n    }\r\n\r\n    return search;\r\n\r\n};\r\n\r\n\r\n/**\r\n * Retrieves a reference to the service running on the current device\r\n *\r\n * @param {Function} callback The callback handler\r\n * @param {Error} callback.error\r\n * @param {Service} callback.service The service instance\r\n *\r\n */\r\nmsf.local = function(callback){\r\n\r\n    Service.getLocal(callback);\r\n\r\n};\r\n\r\n/**\r\n * Retrieves a service instance by it's uri\r\n *\r\n * @param {String} uri The uri of the service (http://<ip>:<port>/api/v2/)\r\n * @param {Function} callback The callback handler\r\n * @param {Error} callback.error\r\n * @param {Service} callback.service The service instance\r\n *\r\n */\r\nmsf.remote = function(uri, callback){\r\n\r\n    Service.getByURI(uri, callback);\r\n\r\n};\r\n\r\n\r\n\r\nmodule.exports = msf;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/msf.js\n ** module id = 1\n ** module chunks = 0\n **/","/* jshint newcap: false, -W040: false, -W004: false, -W003 : false */\r\n\r\n\"use strict\";\r\n\r\n/**\r\n * Based on nodejs EventEmitter\r\n *\r\n * - addition of 'off' method as an alias to `removeListener`\r\n *\r\n * All objects which emit events are instances of EventEmitter.\r\n * For more information see http://nodejs.org/api/events.html\r\n *\r\n * @namespace EventEmitter\r\n *\r\n */\r\n\r\n\r\n/**\r\n * Adds a listener to the end of the listeners array for the specified event.\r\n * @method addListener\r\n * @memberOf EventEmitter.prototype\r\n * @param {String} event The event name to listen to\r\n * @param {Function} listener The function to invoke when the event occurs\r\n * @return EventEmitter\r\n *\r\n */\r\n\r\n/**\r\n * Alias for addListener method\r\n * @method on\r\n * @memberOf EventEmitter.prototype\r\n * @param {String} event The event name to listen to\r\n * @param {Function} listener The function to invoke when the event occurs\r\n * @return EventEmitter\r\n *\r\n */\r\n\r\n/**\r\n * Adds a one time listener for the event. This listener is invoked only the next time the event is fired, after which it is removed.\r\n * @method once\r\n * @memberOf EventEmitter.prototype\r\n * @param {String} event The event name to listen to\r\n * @param {Function} listener The function to invoke when the event occurs\r\n * return EventEmitter\r\n *\r\n */\r\n\r\n/**\r\n * Remove a listener from the listener array for the specified event. Caution: changes array indices in the listener array behind the listener.\r\n * @method removeListener\r\n * @memberOf EventEmitter.prototype\r\n * @param {String} event The event name to stop listening to\r\n * @param {Function} listener The function that was originally add to handle the event\r\n * @return EventEmitter\r\n *\r\n */\r\n\r\n/**\r\n * Alias for removeListener\r\n * @method off\r\n * @memberOf EventEmitter.prototype\r\n * @param {String} event The event name to stop listening to\r\n * @param {Function} listener The function that was originally add to handle the event\r\n * @return EventEmitter\r\n *\r\n */\r\n\r\n/**\r\n * Removes all listeners, or those of the specified event.\r\n * @method removeAllListeners\r\n * @memberOf EventEmitter.prototype\r\n * @param {String} event The event name to stop listening to\r\n * @return EventEmitter\r\n *\r\n */\r\n\r\n/**\r\n * By default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default which helps finding memory leaks. Obviously not all Emitters should be limited to 10. This function allows that to be increased. Set to zero for unlimited.\r\n * @method setMaxListeners\r\n * @memberOf EventEmitter.prototype\r\n * @param {Number} n The maximum number of listeners\r\n *\r\n */\r\n\r\n/**\r\n * Returns an array of listeners for the specified event.\r\n * @method listeners\r\n * @memberOf EventEmitter.prototype\r\n * @param {String} event The event name the listeners are currently bound to\r\n * @return Array\r\n *\r\n */\r\n\r\n/**\r\n * Returns true if event had listeners, false otherwise.\r\n * @method emit\r\n * @memberOf EventEmitter.prototype\r\n * @param {String} event The event name the listeners are currently bound to\r\n * @param {any}[args]*\r\n * @return Boolean\r\n *\r\n */\r\n\r\n/**\r\n * Returns true if event had listeners, false otherwise.\r\n * @method listenerCount\r\n * @static\r\n * @memberOf EventEmitter\r\n * @param {EventEmitter} emitter\r\n * @param {String} event The event name the listeners are currently bound to\r\n * @return Number\r\n *\r\n */\r\n\r\n\r\n/**\r\n This event is emitted any time someone adds a new listener. It is unspecified if listener is in the list returned by emitter.listeners(event).\r\n @event EventEmitter#newListener\r\n @property {String} event The event name\r\n @property {Function} listener The event handler function\r\n **/\r\n\r\n/**\r\n This event is emitted any time someone removes a listener. It is unspecified if listener is in the list returned by emitter.listeners(event).\r\n @event EventEmitter#removeListener\r\n @property {String} event The event name\r\n @property {Function} listener The event handler function\r\n **/\r\n\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nfunction EventEmitter() {\r\n this._events = this._events || {};\r\n this._maxListeners = this._maxListeners || undefined;\r\n}\r\nmodule.exports = EventEmitter;\r\n\r\n// Backwards-compat with node 0.10.x\r\nEventEmitter.EventEmitter = EventEmitter;\r\n\r\nEventEmitter.prototype._events = undefined;\r\nEventEmitter.prototype._maxListeners = undefined;\r\n\r\n// By default EventEmitters will print a warning if more than 10 listeners are\r\n// added to it. This is a useful default which helps finding memory leaks.\r\nEventEmitter.defaultMaxListeners = 10;\r\n\r\n// Obviously not all Emitters should be limited to 10. This function allows\r\n// that to be increased. Set to zero for unlimited.\r\nEventEmitter.prototype.setMaxListeners = function(n) {\r\n if (!isNumber(n) || n < 0 || isNaN(n))\r\n  throw TypeError('n must be a positive number');\r\n this._maxListeners = n;\r\n return this;\r\n};\r\n\r\nEventEmitter.prototype.emit = function(type) {\r\n var er, handler, len, args, i, listeners;\r\n\r\n if (!this._events)\r\n  this._events = {};\r\n\r\n // If there is no 'error' event listener then throw.\r\n if (type === 'error') {\r\n  if (!this._events.error ||\r\n      (isObject(this._events.error) && !this._events.error.length)) {\r\n   er = arguments[1];\r\n   if (er instanceof Error) {\r\n    throw er; // Unhandled 'error' event\r\n   }\r\n   throw TypeError('Uncaught, unspecified \"error\" event.');\r\n  }\r\n }\r\n\r\n handler = this._events[type];\r\n\r\n if (isUndefined(handler))\r\n  return false;\r\n\r\n if (isFunction(handler)) {\r\n  switch (arguments.length) {\r\n   // fast cases\r\n   case 1:\r\n    handler.call(this);\r\n    break;\r\n   case 2:\r\n    handler.call(this, arguments[1]);\r\n    break;\r\n   case 3:\r\n    handler.call(this, arguments[1], arguments[2]);\r\n    break;\r\n   // slower\r\n   default:\r\n    len = arguments.length;\r\n    args = new Array(len - 1);\r\n    for (i = 1; i < len; i++)\r\n     args[i - 1] = arguments[i];\r\n    handler.apply(this, args);\r\n  }\r\n } else if (isObject(handler)) {\r\n  len = arguments.length;\r\n  args = new Array(len - 1);\r\n  for (i = 1; i < len; i++)\r\n   args[i - 1] = arguments[i];\r\n\r\n  listeners = handler.slice();\r\n  len = listeners.length;\r\n  for (i = 0; i < len; i++)\r\n   listeners[i].apply(this, args);\r\n }\r\n\r\n return true;\r\n};\r\n\r\nEventEmitter.prototype.addListener = function(type, listener) {\r\n var m;\r\n\r\n if (!isFunction(listener))\r\n  throw TypeError('listener must be a function');\r\n\r\n if (!this._events)\r\n  this._events = {};\r\n\r\n // To avoid recursion in the case that type === \"newListener\"! Before\r\n // adding it to the listeners, first emit \"newListener\".\r\n if (this._events.newListener)\r\n  this.emit('newListener', type,\r\n      isFunction(listener.listener) ?\r\n          listener.listener : listener);\r\n\r\n if (!this._events[type])\r\n // Optimize the case of one listener. Don't need the extra array object.\r\n  this._events[type] = listener;\r\n else if (isObject(this._events[type]))\r\n // If we've already got an array, just append.\r\n  this._events[type].push(listener);\r\n else\r\n // Adding the second element, need to change to array.\r\n  this._events[type] = [this._events[type], listener];\r\n\r\n // Check for listener leak\r\n if (isObject(this._events[type]) && !this._events[type].warned) {\r\n  var m;\r\n  if (!isUndefined(this._maxListeners)) {\r\n   m = this._maxListeners;\r\n  } else {\r\n   m = EventEmitter.defaultMaxListeners;\r\n  }\r\n\r\n  if (m && m > 0 && this._events[type].length > m) {\r\n   this._events[type].warned = true;\r\n   console.error('(node) warning: possible EventEmitter memory ' +\r\n       'leak detected. %d listeners added. ' +\r\n       'Use emitter.setMaxListeners() to increase limit.',\r\n       this._events[type].length);\r\n   if (typeof console.trace === 'function') {\r\n    // not supported in IE 10\r\n    console.trace();\r\n   }\r\n  }\r\n }\r\n\r\n return this;\r\n};\r\n\r\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\r\n\r\nEventEmitter.prototype.once = function(type, listener) {\r\n if (!isFunction(listener))\r\n  throw TypeError('listener must be a function');\r\n\r\n var fired = false;\r\n\r\n function g() {\r\n  this.removeListener(type, g);\r\n\r\n  if (!fired) {\r\n   fired = true;\r\n   listener.apply(this, arguments);\r\n  }\r\n }\r\n\r\n g.listener = listener;\r\n this.on(type, g);\r\n\r\n return this;\r\n};\r\n\r\n// emits a 'removeListener' event iff the listener was removed\r\nEventEmitter.prototype.removeListener = function(type, listener) {\r\n var list, position, length, i;\r\n\r\n if (!isFunction(listener))\r\n  throw TypeError('listener must be a function');\r\n\r\n if (!this._events || !this._events[type])\r\n  return this;\r\n\r\n list = this._events[type];\r\n length = list.length;\r\n position = -1;\r\n\r\n if (list === listener ||\r\n     (isFunction(list.listener) && list.listener === listener)) {\r\n  delete this._events[type];\r\n  if (this._events.removeListener)\r\n   this.emit('removeListener', type, listener);\r\n\r\n } else if (isObject(list)) {\r\n  for (i = length; i-- > 0;) {\r\n   if (list[i] === listener ||\r\n       (list[i].listener && list[i].listener === listener)) {\r\n    position = i;\r\n    break;\r\n   }\r\n  }\r\n\r\n  if (position < 0)\r\n   return this;\r\n\r\n  if (list.length === 1) {\r\n   list.length = 0;\r\n   delete this._events[type];\r\n  } else {\r\n   list.splice(position, 1);\r\n  }\r\n\r\n  if (this._events.removeListener)\r\n   this.emit('removeListener', type, listener);\r\n }\r\n\r\n return this;\r\n};\r\n\r\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\r\n\r\nEventEmitter.prototype.removeAllListeners = function(type) {\r\n var key, listeners;\r\n\r\n if (!this._events)\r\n  return this;\r\n\r\n // not listening for removeListener, no need to emit\r\n if (!this._events.removeListener) {\r\n  if (arguments.length === 0)\r\n   this._events = {};\r\n  else if (this._events[type])\r\n   delete this._events[type];\r\n  return this;\r\n }\r\n\r\n // emit removeListener for all listeners on all events\r\n if (arguments.length === 0) {\r\n  for (key in this._events) {\r\n   if (key === 'removeListener') continue;\r\n   this.removeAllListeners(key);\r\n  }\r\n  this.removeAllListeners('removeListener');\r\n  this._events = {};\r\n  return this;\r\n }\r\n\r\n listeners = this._events[type];\r\n\r\n if (isFunction(listeners)) {\r\n  this.removeListener(type, listeners);\r\n } else {\r\n  // LIFO order\r\n  while (listeners.length)\r\n   this.removeListener(type, listeners[listeners.length - 1]);\r\n }\r\n delete this._events[type];\r\n\r\n return this;\r\n};\r\n\r\nEventEmitter.prototype.listeners = function(type) {\r\n var ret;\r\n if (!this._events || !this._events[type])\r\n  ret = [];\r\n else if (isFunction(this._events[type]))\r\n  ret = [this._events[type]];\r\n else\r\n  ret = this._events[type].slice();\r\n return ret;\r\n};\r\n\r\nEventEmitter.listenerCount = function(emitter, type) {\r\n var ret;\r\n if (!emitter._events || !emitter._events[type])\r\n  ret = 0;\r\n else if (isFunction(emitter._events[type]))\r\n  ret = 1;\r\n else\r\n  ret = emitter._events[type].length;\r\n return ret;\r\n};\r\n\r\nfunction isFunction(arg) {\r\n return typeof arg === 'function';\r\n}\r\n\r\nfunction isNumber(arg) {\r\n return typeof arg === 'number';\r\n}\r\n\r\nfunction isObject(arg) {\r\n return typeof arg === 'object' && arg !== null;\r\n}\r\n\r\nfunction isUndefined(arg) {\r\n return arg === void 0;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/EventEmitter.js\n ** module id = 2\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util = require(\"./util\");\r\nvar props = util.props;\r\nvar Application = require('./Application');\r\nvar Channel = require('./Channel');\r\n\r\n\r\n/**\r\n * A Service instance represents the multiscreen service root on the remote device\r\n * Use the class to control top level services of the device\r\n *\r\n * @namespace Service\r\n *\r\n */\r\n\r\nfunction Service(description){\r\n\r\n    /**\r\n     * The id of the service\r\n     *\r\n     * @member {String} Service#id\r\n     * @readonly\r\n     */\r\n    this.id = description.id;\r\n\r\n    /**\r\n     * The name of the service (Living Room TV)\r\n     *\r\n     * @member {String} Service#name\r\n     * @readonly\r\n     */\r\n    this.name = description.name;\r\n\r\n    /**\r\n     * The version of the service (x.x.x)\r\n     *\r\n     * @member {String} Service#version\r\n     * @readonly\r\n     */\r\n    this.version = description.version;\r\n\r\n    /**\r\n     * The type of the service (Samsung SmartTV)\r\n     *\r\n     * @member {String} Service#type\r\n     * @readonly\r\n     */\r\n    this.type = description.type;\r\n\r\n    /**\r\n     * The uri of the service (http://<ip>:<port>/api/v2/)\r\n     *\r\n     * @member {String} Service#uri\r\n     * @readonly\r\n     */\r\n    this.uri = description.uri;\r\n\r\n    /**\r\n     * A hash of additional information about the device the service is running on\r\n     *\r\n     * @member {String} Service#device\r\n     * @readonly\r\n     */\r\n    this.device = description.device;\r\n\r\n    props.readOnly(this,['id','name','version','type','uri','device']);\r\n\r\n}\r\n\r\n/**\r\n * Factory method for creating application instances belonging to that service\r\n *\r\n * @param {String} id An installed application id or url of the web application\r\n * @param {String} channelURI The uri the underlying channel will connect to.\r\n * @returns {Application}\r\n *\r\n */\r\nService.prototype.application = function(id, channelURI){\r\n\r\n    return new Application(this, id, channelURI);\r\n\r\n};\r\n\r\n/**\r\n * creates a channel of the service ('mychannel')\r\n *\r\n * @param {String} uri The uri of the Channel\r\n * @returns {Channel}\r\n */\r\nService.prototype.channel = function(uri){\r\n\r\n    return new Channel(this, uri);\r\n\r\n};\r\n\r\n\r\n/***\r\n * Retrieves a reference to the service running on the current device\r\n *\r\n * @protected\r\n *\r\n * @param {Function} callback The callback handler\r\n * @param {Error} callback.err The callback handler\r\n * @param {Service} callback.service The service instance\r\n *\r\n */\r\nService.getLocal = function(callback){\r\n\r\n    Service.getByURI('http://127.0.0.1:8001/api/v2/', callback);\r\n\r\n};\r\n\r\n/***\r\n * Retrieves a service instance by it's uri\r\n *\r\n * @protected\r\n *\r\n * @param {String} uri The uri of the service (http://<ip>:<port>/api/v2/)\r\n * @param {Function} callback The callback handler\r\n * @param {Error} callback.err The callback handler\r\n * @param {Service} callback.service The service instance\r\n *\r\n */\r\nService.getByURI = function(uri, callback){\r\n\r\n    var oReq = new XMLHttpRequest();\r\n    oReq.timeout = 5000;\r\n    oReq.ontimeout = function(){callback();};\r\n    oReq.onload = function() {\r\n\r\n        if(this.status === 200){\r\n            try{\r\n                var result = JSON.parse(this.responseText);\r\n                callback(null, new Service(result));\r\n            }catch(e){  callback(e); }\r\n        }else{\r\n            callback();\r\n        }\r\n    };\r\n    oReq.open(\"get\", uri, true);\r\n    oReq.send();\r\n\r\n};\r\n\r\n\r\nmodule.exports = Service;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Service.js\n ** module id = 3\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util = require(\"./util\");\r\nvar props = util.props;\r\nvar EventEmitter = require('./EventEmitter');\r\n\r\n\r\n/**\r\n * Provides facilities to stop and start multiscreen service searches.\r\n *\r\n * @namespace Search\r\n * @extends EventEmitter\r\n *\r\n */\r\n\r\nfunction Search(){\r\n\r\n\r\n    Search.super_.call(this);\r\n\r\n    this.discoveryFrame = null;\r\n    this.status = Search.STATUS_STOPPED;\r\n\r\n    var self = this;\r\n\r\n    /* Create the discovery iframe and load the search page */\r\n\r\n    var frame = document.createElement('iframe');\r\n    frame.setAttribute('width', '1');\r\n    frame.setAttribute('height', '1');\r\n    frame.style.display = \"none\";\r\n    frame.src = 'http://multiscreen.samsung.com/discoveryservice/v2/discover';\r\n    document.body.appendChild(frame);\r\n\r\n    /* Add a 'message' listener to the window that checks incoming messages */\r\n\r\n    this.windowMessageListener = function(event){\r\n\r\n        if(event.source === frame.contentWindow){\r\n\r\n            // ready message\r\n            if(event.data && event.data.event === 'discovery.ready'){\r\n                self.discoveryFrame = event.source;\r\n                self.onSearchReady();\r\n            }\r\n\r\n            // result message\r\n            else if(event.data && event.data.event === 'discovery.result'){\r\n                var results = [];\r\n                var Service = require('./Service');\r\n                for(var i=0; i<event.data.result.length; i++){\r\n                    results.push(new Service(event.data.result[i]));\r\n                }\r\n                self.onSearchResult(results);\r\n            }\r\n\r\n            // error message\r\n            else if(event.data && event.data.event === 'discovery.error'){\r\n                self.onSearchError(event.data.error);\r\n                this.status = Search.STATUS_STOPPED;\r\n            }\r\n        }\r\n    };\r\n    window.addEventListener('message', this.windowMessageListener);\r\n\r\n    props.private(this,['discoveryFrame','windowMessageListener']);\r\n\r\n}\r\n\r\nutil.inherits(Search, EventEmitter);\r\n\r\n\r\n/***\r\n * @constant {string}\r\n * @private\r\n */\r\nSearch.STATUS_STOPPED = 'stopped';\r\n\r\n/***\r\n * @constant {string}\r\n * @private\r\n */\r\nSearch.STATUS_STARTED = 'started';\r\n\r\n/***\r\n * @private\r\n */\r\nSearch.prototype.onSearchReady = function(){\r\n    this.emit('ready');\r\n};\r\n\r\n\r\n\r\n/**\r\n * Fired when a search has discovered compatible services\r\n *\r\n * @event Search#found\r\n * @type {Array}\r\n */\r\n\r\n/***\r\n * @private\r\n */\r\nSearch.prototype.onSearchResult = function(results){\r\n    if(this.status !== Search.STATUS_STOPPED){\r\n        this.emit('found',results);\r\n    }\r\n    this.status = Search.STATUS_STOPPED;\r\n};\r\n\r\n\r\n/**\r\n * Fired when a search error has occurred\r\n *\r\n * @event Search#error\r\n * @type {Error}\r\n */\r\n\r\n/***\r\n * @private\r\n */\r\nSearch.prototype.onSearchError = function(error){\r\n    this.emit('error',error);\r\n    this.status = Search.STATUS_STOPPED;\r\n};\r\n\r\n\r\n/**\r\n * Starts the search, looking for devices it can reach on the local network\r\n * If a search is already in progress it will NOT begin a new search\r\n */\r\nSearch.prototype.start = function(){\r\n    if(this.status === Search.STATUS_STOPPED){\r\n        if(this.discoveryFrame){\r\n            this.discoveryFrame.postMessage({method:'discovery.search'}, \"*\");\r\n        }else{\r\n            var self = this;\r\n            this.once('ready',function(){\r\n                self.discoveryFrame.postMessage({method:'discovery.search'}, \"*\");\r\n            });\r\n        }\r\n\r\n        this.status = Search.STATUS_STARTED;\r\n        /**\r\n         * Fired when a search has been started\r\n         *\r\n         * @event Search#start\r\n         * @type {Search}\r\n         */\r\n        this.emit('start', this);\r\n    }else{\r\n        console.warn('a previous search is already in progress');\r\n    }\r\n};\r\n\r\n/**\r\n * Stops the current search in progress (no 'found' events or search callbacks will fire)\r\n */\r\nSearch.prototype.stop = function(){\r\n    this.status = Search.STATUS_STOPPED;\r\n    /**\r\n     * Fired when a search has been stopped\r\n     *\r\n     * @event Search#stop\r\n     * @type {Search}\r\n     */\r\n    this.emit('stop', this);\r\n};\r\n\r\n\r\nmodule.exports = Search;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Search.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = {\r\n\r\n    url         : require('./url'),\r\n    inherits    : require('./inherits'),\r\n    props       : require('./props'),\r\n    types       : require('./types'),\r\n    queryString : require('./querystring')\r\n\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/index.js\n ** module id = 5\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util = require(\"./util\");\r\nvar types = util.types;\r\nvar props = util.props;\r\nvar Channel = require('./Channel');\r\n\r\n\r\n/**\r\n * An Application represents an application on the local or remote device.\r\n * Use the class to control various aspects of the application such launching the app or getting information\r\n *\r\n * @namespace Application\r\n * @extends Channel\r\n *\r\n */\r\n\r\nfunction Application(service, id, channelURI){\r\n\r\n    /* Type checking */\r\n    if(!types.isObject(service)) throw new TypeError('service must be of type Service');\r\n    if(!types.isString(id)) throw new TypeError('id must be a valid string');\r\n    if(!types.isString(channelURI)) throw new TypeError('channelId must be a valid string');\r\n\r\n    /***\r\n     * The type of application (web application or installable app)\r\n     * @member {String} Application#type\r\n     * @private\r\n     */\r\n    this.type = id.match(/(file:\\/\\/|http(s)?:\\/\\/)/gmi) ? 'webapplication' : 'application';\r\n\r\n    /* Super Constructor */\r\n    Application.super_.call(this, service, channelURI);\r\n\r\n\r\n    /**\r\n     * The id of the application (this can be a url or installed application id)\r\n     * @member {String} Application#id\r\n     * @readonly\r\n     */\r\n    this.id = id;\r\n\r\n    /**\r\n     * Auto starts the application when connect is called\r\n     * This configuration property has no effect when used in a SmartTV application\r\n     *\r\n     * @member {Boolean} Application#startOnConnect\r\n     * @default [true]\r\n     * @example\r\n     * ```\r\n     * var app = service.application('myid');\r\n     * app.startOnConnect = false;\r\n     * app.connect(); // The application will not start on the TV\r\n     * ```\r\n     */\r\n    this.startOnConnect      = true;\r\n\r\n    /**\r\n     * Stops the application when disconnect is called and your client is the last client connected\r\n     * This configuration property has no effect when used in a SmartTV application\r\n     *\r\n     * @member {Boolean} Application#stopOnDisconnect\r\n     * @default [true]\r\n     * @example\r\n     * ```\r\n     * var app = service.application('myid');\r\n     * app.stopOnDisconnect = false;\r\n     * app.disconnect(); // The application will not close on the TV\r\n     * ```\r\n     */\r\n    this.stopOnDisconnect    = true;\r\n\r\n    /**\r\n     * Disconnects your client when the host connection ends (when the host application is exited)\r\n     * This configuration property has no effect when used in a SmartTV application\r\n     *\r\n     * @member {Boolean} Application#disconnectWithHost\r\n     * @default [true]\r\n     * @example\r\n     * ```\r\n     * app.on('clientDisconnect', function(client){\r\n     *    // client.isHost == true; but you will not be disconnected.\r\n     * });\r\n     * ```\r\n     */\r\n    this.disconnectWithHost  = true;\r\n\r\n\r\n    var self = this;\r\n\r\n    /* Listen for connect events and call start if startOnConnect */\r\n    this.on('connect', function(client){\r\n        if(self.startOnConnect && !self.clients.me.isHost) this.start();\r\n    });\r\n\r\n    /* Listen for clientDisconnect events and disconnect if host disconnects  */\r\n    this.on('clientDisconnect', function(client){\r\n        if(self.disconnectWithHost && client.isHost) this.disconnect();\r\n    });\r\n\r\n    /* Overwrite super disconnect and stop the app if stopOnDisconnect */\r\n    this.disconnect = function(callback){\r\n        if(self.stopOnDisconnect && self.clients.length < 3) {\r\n            self.stop(function(){\r\n                Channel.prototype.disconnect.call(self, callback);\r\n            });\r\n        }else{\r\n            Channel.prototype.disconnect.call(self, callback);\r\n        }\r\n    };\r\n\r\n    props.readOnly(this,'id');\r\n    props.private(this,'type');\r\n\r\n}\r\n\r\nutil.inherits(Application, Channel);\r\n\r\n\r\n/**\r\n * Retrieves information about the Application on the remote device\r\n *\r\n * @param {Function} callback The callback handler\r\n * @param {Function} callback.err The callback handler\r\n * @param {Object} callback.result The callback handler\r\n *\r\n */\r\nApplication.prototype.getInfo = function(callback){\r\n\r\n    if(this.type === 'webapplication'){\r\n        this.invoke('ms.webapplication.get', { url: this.id }, callback);\r\n    }else{\r\n        this.invoke('ms.application.get', { id : this.id }, callback);\r\n    }\r\n\r\n};\r\n\r\n\r\n/**\r\n * Launches the application on the remote device\r\n *\r\n * @param {Function} callback The callback handler\r\n * @param {Function} callback.err The callback handler\r\n *\r\n */\r\nApplication.prototype.start = function(callback){\r\n\r\n    if(this.type === 'webapplication'){\r\n        this.invoke('ms.webapplication.start', { url : this.id }, callback);\r\n    }else{\r\n        this.invoke('ms.application.start', { id : this.id }, callback);\r\n    }\r\n\r\n};\r\n\r\n\r\n/**\r\n * Stop the application on the remote device\r\n *\r\n * @param {Function} callback The callback handler\r\n * @param {Function} callback.err The callback handler\r\n *\r\n */\r\nApplication.prototype.stop = function(callback){\r\n\r\n    if(this.type === 'webapplication'){\r\n        this.invoke('ms.webapplication.stop', { url : this.id }, callback);\r\n    }else{\r\n        this.invoke('ms.application.stop', { id : this.id }, callback);\r\n    }\r\n\r\n};\r\n\r\n\r\n/**\r\n * Installs the application on the remote device\r\n *\r\n * @param {Function} callback The callback handler\r\n * @param {Function} callback.err The callback handler\r\n *\r\n */\r\nApplication.prototype.install = function(callback){\r\n\r\n    if(this.type === 'webapplication') throw new Error('install cannot be called on web applications');\r\n    this.invoke('ms.application.install', { id : this.id }, callback);\r\n\r\n};\r\n\r\n\r\n\r\n\r\nmodule.exports = Application;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Application.js\n ** module id = 6\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util = require(\"./util\");\r\nvar types = util.types;\r\nvar props = util.props;\r\nvar EventEmitter = require('./EventEmitter');\r\nvar Client = require('./Client');\r\nvar ClientList = require('./ClientList');\r\n\r\n\r\n/**\r\n * A Channel is a discreet connection where multiple clients can communicate\r\n * @namespace Channel\r\n * @extends EventEmitter\r\n\r\n */\r\nfunction Channel(service, uri){\r\n\r\n    /* Type checking */\r\n    if(!types.isObject(service)) throw new TypeError('service must be of type Service');\r\n    if(!types.isString(uri)) throw new TypeError('uri must be a valid string');\r\n\r\n    /* Super Construction */\r\n    Channel.super_.call(this);\r\n\r\n    var self = this;\r\n    var oServiceUrl = util.url.parse(service.uri);\r\n\r\n    /**\r\n     * The uri of the channel ('chat')\r\n     *\r\n     * @member {String} Channel#uri\r\n     * @readonly\r\n     *\r\n     */\r\n    this.uri = uri;\r\n\r\n    /**\r\n     * The collection of clients currently connected to the channel\r\n     *\r\n     * @member {ClientList} Channel#clients\r\n     * @readonly\r\n     *\r\n     */\r\n    this.clients = new ClientList(this);\r\n\r\n    /**\r\n     * The connection status of the channel\r\n     *\r\n     * @member {Boolean} Channel#isConnected\r\n     * @readonly\r\n     *\r\n     */\r\n    Object.defineProperty(this, 'isConnected', {\r\n        get : function(){\r\n            return self.connection && self.connection.readyState === 1;\r\n        }\r\n    });\r\n\r\n    /***\r\n     * The id assigned to your client upon connection\r\n     *\r\n     * @member {String} Channel#clientId\r\n     * @private\r\n     *\r\n     */\r\n    this.clientId = null;\r\n\r\n    /***\r\n     * The underlying web socket connection\r\n     *\r\n     * @member {WebSocket} Channel#connection\r\n     * @private\r\n     *\r\n     */\r\n    this.connection = null;\r\n\r\n    /***\r\n     * A map of message handler still waiting for responses\r\n     *\r\n     * @member {Object} Channel#resultHandlers\r\n     * @private\r\n     *\r\n     */\r\n    this.resultHandlers = {};\r\n\r\n    /***\r\n     * The url for the websocket to connect to\r\n     *\r\n     * @member {Object} Channel#connectionUrl\r\n     * @private\r\n     *\r\n     */\r\n    this.connectionUrl = 'ws://' + oServiceUrl.host + oServiceUrl.pathname + 'channels/' + uri;\r\n\r\n\r\n    props.private(this, ['clientId','connection','resultHandlers','connectionUrl']);\r\n    props.readOnly(this, ['uri','clients']);\r\n}\r\n\r\n\r\nutil.inherits(Channel, EventEmitter);\r\n\r\n\r\n/*\r\n Packs messages with payloads into binary message\r\n */\r\nChannel.packMessage = function(oMsg, payload){\r\n\r\n    // convert js object to string\r\n    var msg = JSON.stringify(oMsg);\r\n\r\n    // get byte length of the string\r\n    var msgByteLength = new Blob([msg]).size;\r\n\r\n    // create 2 byte header which contains the length of the string (json) message\r\n    var hBuff = new ArrayBuffer(2);\r\n    var hView = new DataView(hBuff);\r\n    hView.setUint16(0,msgByteLength);\r\n\r\n    // binary packed message and payload\r\n    return new Blob([hBuff, msg, payload]);\r\n\r\n};\r\n\r\n/*\r\n Unpacks binary messages\r\n */\r\nChannel.unpackMessage = function(buffer){\r\n\r\n    var json = '';\r\n    var view = new DataView(buffer);\r\n    var msgByteLen = view.getUint16(0);\r\n\r\n    for (var i = 0; i < msgByteLen; i++) {\r\n        json += String.fromCharCode(view.getUint8(i+2));\r\n    }\r\n\r\n    var payload = buffer.slice(2+msgByteLen);\r\n    var message = JSON.parse(json);\r\n\r\n    return {payload : payload, message : message};\r\n\r\n};\r\n\r\n\r\n/***\r\n * Invokes and RPC method on the server\r\n *\r\n * @protected\r\n *\r\n * @param {String} method The name of the method to invoke\r\n * @param {Object} params Named params to pass to the method\r\n * @param {Function} [callback] The success callback handler\r\n * @param {Error} callback.error Any error that may have occurred\r\n * @param {Boolean} callback.success\r\n * @param {Boolean} [isNotification=false] If true the message will have no id and no response handler will be stored\r\n * @param {ArrayBuffer|Blob} [payload] Any binary data to send along with the message\r\n *\r\n */\r\nChannel.prototype.invoke = function(method, params, callback, isNotification, payload){\r\n\r\n    if(!this.isConnected) throw new Error(\"the channel is disconnected\");\r\n    if(!types.isString(method))throw new TypeError('method must be a valid string');\r\n\r\n    params = params || {};\r\n\r\n    var msg = {\r\n        method  : method,\r\n        params  : params\r\n    };\r\n\r\n    if(callback && !isNotification){\r\n        msg.id = Date.now();\r\n        this.resultHandlers[msg.id] = callback;\r\n    }\r\n\r\n    if(payload){\r\n        msg = Channel.packMessage(msg,payload);\r\n    }else{\r\n        msg = JSON.stringify(msg);\r\n    }\r\n\r\n    this.connection.send(msg);\r\n};\r\n\r\n/**\r\n * Connects to the channel\r\n *\r\n * @param {Object} attributes Any attributes you want to associate with the client (ie. {name:\"FooBar\"}\r\n * @param {Function} callback The success callback handler\r\n * @param {Error} callback.error Any error that may have occurred\r\n * @param {Channel} callback.channel The channel instance that connected\r\n *\r\n */\r\nChannel.prototype.connect = function(attributes, callback){\r\n\r\n    if(types.isFunction(attributes) && !callback){\r\n        callback = attributes;\r\n        attributes = {};\r\n    }else{\r\n        attributes = attributes || {};\r\n    }\r\n\r\n    // Validate arguments and connection state\r\n    if(!types.isObject(attributes))throw new TypeError('attributes must be a valid object');\r\n    if(callback && !types.isFunction(callback))throw new TypeError('callback must be a valid function');\r\n    if(this.isConnected) return console.warn('Channel is already connected.');\r\n\r\n    // TODO : Need to merge query string just in case the connection url already has a query (although it shouldn't)\r\n    var u = this.connectionUrl + '?' + util.queryString.stringify(attributes);\r\n\r\n    // Connect the websocket and add our listeners\r\n    if(!this.connection){\r\n        this.connection = new WebSocket(u);\r\n        this.connection.binaryType = \"arraybuffer\";\r\n        this.connection.onopen = this._onSocketOpen.bind(this);\r\n        this.connection.onerror = this._onSocketError.bind(this);\r\n        this.connection.onclose = this._onSocketClose.bind(this);\r\n        this.connection.onmessage = this._onSocketMessage.bind(this);\r\n    }\r\n\r\n    // Listen once for connect if there was a callback\r\n    var self = this;\r\n    if(callback){\r\n        this.once('connect', function(client){\r\n            callback(null, self);\r\n        });\r\n    }\r\n\r\n\r\n};\r\n\r\n\r\n/**\r\n * Disconnects from the channel\r\n *\r\n * @param {Function} callback The success callback handler\r\n * @param {Error} callback.error Any error that may have occurred\r\n * @param {Channel} callback.channel The channel instance\r\n *\r\n */\r\nChannel.prototype.disconnect = function(callback){\r\n\r\n    if(!this.isConnected) throw new Error(\"the channel is already disconnected\");\r\n    this.connection.close();\r\n    var self = this;\r\n    setTimeout(function(){\r\n        if(callback) callback(null, self);\r\n    },0);\r\n\r\n};\r\n\r\n\r\n/**\r\n * Publish an event message to the specified target or targets.\r\n * Targets can be in the for of a clients id, an array of client ids or one of the special message target strings (ie. \"all\" or \"host\"}\r\n *\r\n * @param {String} event The name of the event to emit\r\n * @param {any} [message] Any data associated with the event\r\n * @param {String|Array} [target='broadcast'] The target recipient(s) of the message\r\n * @param {Blob|ArrayBuffer} [payload] Any binary data to send with the message\r\n *\r\n */\r\nChannel.prototype.publish = function(event, message, target, payload){\r\n\r\n    target = target || 'broadcast';\r\n    message = message || null;\r\n\r\n    if(!this.isConnected) throw new Error(\" the channel is not connected\");\r\n    if(!types.isString(event))throw new TypeError('event must be a valid string');\r\n\r\n    if(!(types.isString(target) || types.isArray(target))) throw new TypeError('targets must be a valid string or array');\r\n\r\n    this.invoke('ms.channel.emit',{\r\n        event   : event,\r\n        data    : message,\r\n        to      : target\r\n    }, null, true, payload);\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n// TODO : Make these non enumerable\r\n\r\n\r\nChannel.prototype._onSocketOpen = function() {\r\n    // nothing to do here for now\r\n};\r\n\r\nChannel.prototype._onSocketClose = function() {\r\n    /**\r\n     * Fired when a channel disconnects\r\n     *\r\n     * @event Channel#disconnect\r\n     * @type {Client}\r\n     */\r\n    var client = this.clients.me;\r\n    this.clients.clear();\r\n    this.emit('disconnect',client);\r\n};\r\n\r\nChannel.prototype._onSocketError = function() {\r\n    this.emit('error', new Error(\"WebSocket error\"));\r\n};\r\n\r\n\r\nChannel.prototype._onSocketMessage = function(msg){\r\n\r\n    var client;\r\n    var payload;\r\n\r\n    try{\r\n        if(typeof msg.data === \"string\"){\r\n            msg = JSON.parse(msg.data);\r\n        }else{\r\n            var unpacked = Channel.unpackMessage(msg.data);\r\n            msg = unpacked.message;\r\n            payload = unpacked.payload;\r\n        }\r\n    } catch (e) {\r\n        console.warn('unable to parse message', msg);\r\n        return;\r\n    }\r\n\r\n    if(msg.id && (msg.result || msg.error)){\r\n\r\n        if(!this.resultHandlers[msg.id]){\r\n            console.warn('unable to find result handler for result message ', msg);\r\n            return;\r\n        }\r\n\r\n        this.resultHandlers[msg.id](msg.error,msg.result);\r\n\r\n    }else if (msg.event){\r\n\r\n        switch(msg.event){\r\n\r\n            case 'ms.channel.connect' :\r\n\r\n                // Store my id\r\n                this.clientId = msg.data.id;\r\n\r\n                // Store the current connected client\r\n                msg.data.clients.forEach(function(clientInfo){\r\n\r\n                    // Create a client and add to our list\r\n                    client = new Client(clientInfo.id, clientInfo.attributes, clientInfo.isHost);\r\n                    this.clients.push(client);\r\n\r\n                },this);\r\n\r\n                /**\r\n                 * Fired when a channel makes a connection\r\n                 *\r\n                 * @event Channel#connect\r\n                 * @type {Client}\r\n                 */\r\n                this.emit('connect',this.clients.me);\r\n\r\n                break;\r\n\r\n            case 'ms.channel.clientConnect' :\r\n\r\n                client = new Client(msg.data.id, msg.data.attributes, msg.data.isHost);\r\n                this.clients.push(client);\r\n\r\n                /**\r\n                 * Fired when a peer client channel makes a connection\r\n                 *\r\n                 * @event Channel#clientConnect\r\n                 * @type {Client}\r\n                 */\r\n\r\n                this.emit('clientConnect',client);\r\n                break;\r\n\r\n            case 'ms.channel.clientDisconnect' :\r\n\r\n                client = this.clients.getById(msg.data.id);\r\n                if(client) this.clients.remove(client);\r\n                else {\r\n                    console.warn('client '+msg.data.id+' could not be found, so it was not removed from the client list');\r\n                    client = new Client(msg.data.id, msg.data.attributes, msg.data.isHost);\r\n                }\r\n\r\n                /**\r\n                 * Fired when a peer client disconnects\r\n                 *\r\n                 * @event Channel#clientDisconnect\r\n                 * @type {Client}\r\n                 */\r\n                this.emit('clientDisconnect',client);\r\n                break;\r\n\r\n            case 'ms.channel.ready' :\r\n\r\n\r\n                /**\r\n                 * Convenience event indicating the host has connected and is ready to accept messages\r\n                 *\r\n                 * @event Channel#ready\r\n                 */\r\n                this.emit('ready');\r\n                break;\r\n\r\n\r\n            default :\r\n\r\n                client = this.clients.getById(msg.from);\r\n                var event = msg.event;\r\n                var data  = msg.data;\r\n\r\n                this.emit(event, data, client, payload);\r\n                break;\r\n\r\n        }\r\n\r\n    }else{\r\n        console.warn('unrecognized message type', msg);\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Channel;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Channel.js\n ** module id = 7\n ** module chunks = 0\n **/","\"use strict\";\r\nvar queryString = require('./querystring');\r\n\r\nvar url = {\r\n\r\n    isValid : function(u){\r\n\r\n        var pattern = /^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/;\r\n        return u.match(pattern) ? true : false;\r\n    },\r\n\r\n    parse : function(u){\r\n\r\n        var oUrl = {};\r\n        var parser = document.createElement('a');\r\n        parser.href = u; // \"http://example.com:3000/pathname/?search=test#hash\";\r\n\r\n        oUrl.href = parser.href; // => \"http://ip:port/path/page?query=string#hash\"\r\n        oUrl.protocol = parser.protocol; // => \"http:\"\r\n        oUrl.hostname = parser.hostname; // => \"example.com\"\r\n        oUrl.port = parser.port;     // => \"3000\"\r\n        oUrl.pathname = parser.pathname; // => \"/pathname/\"\r\n        oUrl.search = parser.search;   // => \"?search=test\"\r\n        oUrl.hash = parser.hash;     // => \"#hash\"\r\n        oUrl.host = parser.host;     // => \"example.com:3000\"\r\n        oUrl.queryString = queryString.parse(parser.search);\r\n\r\n        return oUrl;\r\n    }\r\n\r\n\r\n};\r\n\r\nmodule.exports = url;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/url.js\n ** module id = 8\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nif (typeof Object.create === 'function') {\r\n    // implementation from standard node.js 'util' module\r\n    module.exports = function inherits(ctor, superCtor) {\r\n        ctor.super_ = superCtor;\r\n        ctor.prototype = Object.create(superCtor.prototype, {\r\n            constructor: {\r\n                value: ctor,\r\n                enumerable: false,\r\n                writable: true,\r\n                configurable: true\r\n            }\r\n        });\r\n    };\r\n} else {\r\n    // old school shim for old browsers\r\n    module.exports = function inherits(ctor, superCtor) {\r\n        ctor.super_ = superCtor;\r\n        var TempCtor = function () {};\r\n        TempCtor.prototype = superCtor.prototype;\r\n        ctor.prototype = new TempCtor();\r\n        ctor.prototype.constructor = ctor;\r\n    };\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/inherits.js\n ** module id = 9\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nfunction createDescriptor(e,c,w,v){\r\n    return {\r\n        enumerable : e,\r\n        configurable : c,\r\n        writable : w,\r\n        value : v\r\n    };\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    readOnly : function(obj, key){\r\n\r\n        if(Array.isArray(key)){\r\n            key.forEach(function(k){\r\n                Object.defineProperty(obj, k, createDescriptor(true,true,false,obj[k]));\r\n            });\r\n        }else{\r\n            Object.defineProperty(obj, key, createDescriptor(true,true,false,obj[key]));\r\n        }\r\n\r\n    },\r\n\r\n    private : function(obj, key){\r\n\r\n        if(Array.isArray(key)){\r\n            key.forEach(function(k){ Object.defineProperty(obj, k, createDescriptor(false,true,true,obj[k])); });\r\n        }else{\r\n            Object.defineProperty(obj, key, createDescriptor(false,true,true,obj[key]));\r\n        }\r\n    }\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/props.js\n ** module id = 10\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nmodule.exports = {\r\n\r\n    isString : function(obj){\r\n        return typeof obj === 'string';\r\n    },\r\n\r\n    isNull : function(obj){\r\n        return obj === null;\r\n    },\r\n\r\n    isBoolean : function(obj){\r\n        return typeof obj === 'boolean';\r\n    },\r\n\r\n    isNumber : function(obj){\r\n        return typeof obj === 'number';\r\n    },\r\n\r\n    isObject : function(obj){\r\n        return obj === Object(obj);\r\n    },\r\n\r\n    isArray : function(obj){\r\n        return obj.constructor === Array;\r\n    },\r\n\r\n    isFunction : function(obj){\r\n        return typeof obj === 'function';\r\n    }\r\n\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/types.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\r\n\r\n/*\r\n    Derived work from Sidre Sorhus (https://github.com/sindresorhus/query-string)\r\n */\r\n\r\n/*!\r\n query-string\r\n Parse and stringify URL query strings\r\n https://github.com/sindresorhus/query-string\r\n by Sindre Sorhus\r\n MIT License\r\n */\r\n\r\nvar queryString = {};\r\n\r\nqueryString.parse = function (str) {\r\n    if (typeof str !== 'string') {\r\n        return {};\r\n    }\r\n\r\n    str = str.trim().replace(/^(\\?|#)/, '');\r\n\r\n    if (!str) {\r\n        return {};\r\n    }\r\n\r\n    return str.trim().split('&').reduce(function (ret, param) {\r\n        var parts = param.replace(/\\+/g, ' ').split('=');\r\n        var key = parts[0];\r\n        var val = parts[1];\r\n\r\n        key = decodeURIComponent(key);\r\n        // missing `=` should be `null`:\r\n        // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\r\n        val = val === undefined ? null : decodeURIComponent(val);\r\n\r\n        if (!ret.hasOwnProperty(key)) {\r\n            ret[key] = val;\r\n        } else if (Array.isArray(ret[key])) {\r\n            ret[key].push(val);\r\n        } else {\r\n            ret[key] = [ret[key], val];\r\n        }\r\n\r\n        return ret;\r\n    }, {});\r\n};\r\n\r\nqueryString.stringify = function (obj) {\r\n    return obj ? Object.keys(obj).map(function (key) {\r\n        var val = obj[key];\r\n\r\n        if (Array.isArray(val)) {\r\n            return val.map(function (val2) {\r\n                return encodeURIComponent(key) + '=' + encodeURIComponent(val2);\r\n            }).join('&');\r\n        }\r\n\r\n        return encodeURIComponent(key) + '=' + encodeURIComponent(val);\r\n    }).join('&') : '';\r\n};\r\n\r\nmodule.exports = queryString;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/querystring.js\n ** module id = 12\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util = require(\"./util\");\r\nvar types = util.types;\r\n\r\n\r\n/**\r\n * @namespace Client\r\n *\r\n */\r\nfunction ChannelClient(id, attributes, isHost, connectTime){\r\n\r\n    if(!types.isString(id)) throw new TypeError('id must be a valid string');\r\n    if(attributes && !types.isObject(attributes)) throw new TypeError('attributes must be a valid object');\r\n\r\n    /**\r\n     * The id of the client\r\n     *\r\n     * @name id\r\n     * @memberOf Client.prototype\r\n     * @type {String}\r\n     * @readonly\r\n     *\r\n     */\r\n    this.id = id;\r\n\r\n    /**\r\n     * A map of attributes passed by the client when connecting\r\n     *\r\n     * @name attributes\r\n     * @memberOf Client.prototype\r\n     * @type {Object}\r\n     * @readonly\r\n     *\r\n     */\r\n    this.attributes = attributes || {};\r\n\r\n    /**\r\n     * Flag for determining if the client is the host\r\n     *\r\n     * @name isHost\r\n     * @memberOf Client.prototype\r\n     * @type {Boolean}\r\n     * @readonly\r\n     *\r\n     */\r\n    this.isHost = isHost;\r\n\r\n    /**\r\n     * The time which the client connected in epoch milliseconds\r\n     *\r\n     * @name connectTime\r\n     * @memberOf Client.prototype\r\n     * @type {Number}\r\n     * @readonly\r\n     *\r\n     */\r\n    this.connectTime = connectTime || Date.now();\r\n\r\n    Object.freeze(this.attributes);\r\n    Object.freeze(this);\r\n\r\n}\r\n\r\nmodule.exports = ChannelClient;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Client.js\n ** module id = 13\n ** module chunks = 0\n **/","\"use strict\";\r\n\r\nvar util = require(\"./util\");\r\nvar types = util.types;\r\n\r\n/**\r\n * A list of clients\r\n * @namespace ClientList\r\n * @extends Array\r\n */\r\n\r\nfunction ClientList(channel){\r\n\r\n    if(!types.isObject(channel))throw new TypeError('channel must be of type Channel');\r\n\r\n    this.channel = channel;\r\n\r\n    ClientList.super_.call(this);\r\n\r\n}\r\n\r\nutil.inherits(ClientList, Array);\r\n\r\n/***\r\n * Clears the list\r\n * @protected\r\n */\r\nClientList.prototype.clear = function(){\r\n    this.length = 0;\r\n};\r\n\r\n/***\r\n * Removes an client from the list\r\n * @protected\r\n */\r\nClientList.prototype.remove = function(item){\r\n    var i = this.indexOf(item);\r\n    if(i !== -1) {\r\n        this.splice(i, 1);\r\n        return item;\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n/**\r\n * Returns a client by id\r\n *\r\n * @param {String} id The client\r\n * @return {Client}\r\n *\r\n */\r\nClientList.prototype.getById = function(id){\r\n\r\n    if(!types.isString(id) && !types.isNumber(id)) throw new TypeError('id must be a valid string or number');\r\n    for(var i=0; i<this.length; i++){\r\n        if(this[i].id === id) return this[i];\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n/**\r\n * A reference to your client\r\n *\r\n * @member {Client} ClientList#me\r\n * @readonly\r\n */\r\nObject.defineProperty(ClientList.prototype, 'me', {\r\n    get : function(){\r\n        return this.getById(this.channel.clientId);\r\n    }\r\n});\r\n\r\n\r\nmodule.exports = ClientList;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/ClientList.js\n ** module id = 14\n ** module chunks = 0\n **/"],"sourceRoot":""}